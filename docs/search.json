[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Welcome to my blog! Here I share insights from my learning journey, technical discoveries, and thoughts on software development.\n\n\n\n\n\n\nDate: March 2024\nCategory: System Design\nI’ve been diving deep into system design concepts and wanted to share my structured learning approach. From basic scalability patterns to complex distributed systems, here’s how I’m building my knowledge systematically.\n\n\n\nDate: February 2024\nCategory: DSA\nAfter solving 100+ LeetCode problems, I’ve identified common patterns and techniques that make problem-solving more systematic. This post covers my approach to tackling different types of algorithmic challenges.\n\n\n\nDate: January 2024\nCategory: Technical Blogs\nA deep dive into Netflix’s chaos engineering practices and how they ensure system resilience. I break down the key concepts and show how to apply these principles to your own systems.\n\n\n\n\n\n\n\n\nProblem-solving techniques and strategies\nAlgorithm analysis and optimization\nInterview preparation tips and experiences\nCompetitive programming insights\n\n\n\n\n\nArchitecture patterns and best practices\nScalability and performance optimization\nDistributed systems concepts\nReal-world system design case studies\n\n\n\n\n\nAnalysis of engineering blog posts\nKey insights from industry leaders\nPractical applications of concepts\nLearning resources and recommendations\n\n\n\n\n\nDetailed book summaries and takeaways\nReading progress and recommendations\nImplementation of book concepts\nLearning strategies and tips\n\n\n\n\n\nLanguage-specific tips and tricks\nBest practices and code quality\nDevelopment tools and workflows\nProject experiences and lessons learned\n\n\n\n\n\nContainerization and orchestration\nCloud platforms and services\nCI/CD pipelines and automation\nMonitoring and observability\n\n\n\n\n\n\n\n\nClear explanations of complex concepts\nPractical examples and code snippets\nStep-by-step tutorials and guides\nReal-world applications and case studies\n\n\n\n\n\nMy learning journey and experiences\nChallenges faced and solutions found\nMistakes made and lessons learned\nGrowth and progress over time\n\n\n\n\n\nSharing knowledge with others\nEncouraging discussion and feedback\nBuilding connections with fellow developers\nContributing to the broader tech community\n\n\n\n\n\n\n\n\n“Building a Scalable Web Application: Lessons Learned”\n“My Kubernetes Learning Journey: From Docker to Orchestration”\n“Technical Blog Analysis: Uber’s Real-time Data Platform”\n“Book Review: Designing Data-Intensive Applications”\n“DSA Interview Preparation: My 3-Month Plan”\n\n\n\n\n\n“System Design Deep Dive”: Multi-part series on scalable architecture\n“DSA Problem Patterns”: Common algorithmic patterns and solutions\n“Technical Blog Analysis”: Regular breakdowns of engineering articles\n“Learning Path Guides”: Structured learning recommendations\n\n\n\n\n\n\n\nI welcome guest posts from other developers and learners. If you’d like to contribute:\n\nTopic Ideas: Share your expertise and experiences\nTechnical Tutorials: Step-by-step guides and walkthroughs\nCase Studies: Real-world project experiences\nLearning Journeys: Your own path to mastering concepts\n\n\n\n\n\nJoint Posts: Co-author articles on complex topics\nInterview Series: Q&A with experienced developers\nStudy Groups: Collaborative learning content\nProject Showcases: Highlighting community projects\n\n\n\n\n\n\n\n\nTotal Posts: 15+ articles\nMonthly Views: Growing steadily\nEngagement: Active discussions in comments\nTopics Covered: DSA, System Design, Technical Blogs, Books\n\n\n\n\n\nComments: Thoughtful discussions on technical topics\nSocial Shares: Content shared across developer communities\nFeedback: Valuable insights from readers\nQuestions: Technical questions and clarifications\n\n\n\n\n\n\n\n\nStart with the “Learning Path Guides” series\nFocus on fundamental DSA concepts\nBuild a strong foundation before diving into advanced topics\n\n\n\n\n\nExplore system design patterns and case studies\nPractice with the provided code examples\nEngage in discussions and share your experiences\n\n\n\n\n\nContribute guest posts and share your expertise\nProvide feedback and suggestions for improvement\nMentor others in their learning journey\n\n\n\n\n\n\n\nSubscribe to get notified about new posts and learning updates:\nSubscribe to Newsletter\n\n\n\n\nTwitter: @yourhandle - Quick thoughts and updates\nLinkedIn: Your Profile - Professional insights\nGitHub: Your Profile - Code examples and projects\n\n\n\n\nGet updates via RSS: RSS Feed\n\n\n\n\n\n\n\nPublish Frequency: 2-3 posts per month\nContent Quality: In-depth, well-researched articles\nCommunity Engagement: Active discussions and feedback\nSkill Development: Improve writing and communication\n\n\n\n\n\nThought Leadership: Establish expertise in key areas\nCommunity Building: Create a learning-focused community\nKnowledge Sharing: Help others in their learning journey\nProfessional Growth: Build a strong personal brand\n\n\n\n\n\n\n\nWriting Tips for Developers\n\n\n\n\nStart with an outline: Plan your post structure before writing\nInclude code examples: Show, don’t just tell\nUse clear explanations: Break down complex concepts\nEngage with readers: Encourage comments and discussion\nBe consistent: Regular posting builds audience\n\n\n\n\n\n\n\n\n\nCommon Blogging Mistakes\n\n\n\n\nToo much theory: Balance with practical examples\nPoor formatting: Use headers, lists, and code blocks\nNo engagement: Respond to comments and questions\nInconsistent posting: Maintain regular schedule"
  },
  {
    "objectID": "blog.html#recent-posts",
    "href": "blog.html#recent-posts",
    "title": "Blog",
    "section": "",
    "text": "Date: March 2024\nCategory: System Design\nI’ve been diving deep into system design concepts and wanted to share my structured learning approach. From basic scalability patterns to complex distributed systems, here’s how I’m building my knowledge systematically.\n\n\n\nDate: February 2024\nCategory: DSA\nAfter solving 100+ LeetCode problems, I’ve identified common patterns and techniques that make problem-solving more systematic. This post covers my approach to tackling different types of algorithmic challenges.\n\n\n\nDate: January 2024\nCategory: Technical Blogs\nA deep dive into Netflix’s chaos engineering practices and how they ensure system resilience. I break down the key concepts and show how to apply these principles to your own systems."
  },
  {
    "objectID": "blog.html#blog-categories",
    "href": "blog.html#blog-categories",
    "title": "Blog",
    "section": "",
    "text": "Problem-solving techniques and strategies\nAlgorithm analysis and optimization\nInterview preparation tips and experiences\nCompetitive programming insights\n\n\n\n\n\nArchitecture patterns and best practices\nScalability and performance optimization\nDistributed systems concepts\nReal-world system design case studies\n\n\n\n\n\nAnalysis of engineering blog posts\nKey insights from industry leaders\nPractical applications of concepts\nLearning resources and recommendations\n\n\n\n\n\nDetailed book summaries and takeaways\nReading progress and recommendations\nImplementation of book concepts\nLearning strategies and tips\n\n\n\n\n\nLanguage-specific tips and tricks\nBest practices and code quality\nDevelopment tools and workflows\nProject experiences and lessons learned\n\n\n\n\n\nContainerization and orchestration\nCloud platforms and services\nCI/CD pipelines and automation\nMonitoring and observability"
  },
  {
    "objectID": "blog.html#writing-style",
    "href": "blog.html#writing-style",
    "title": "Blog",
    "section": "",
    "text": "Clear explanations of complex concepts\nPractical examples and code snippets\nStep-by-step tutorials and guides\nReal-world applications and case studies\n\n\n\n\n\nMy learning journey and experiences\nChallenges faced and solutions found\nMistakes made and lessons learned\nGrowth and progress over time\n\n\n\n\n\nSharing knowledge with others\nEncouraging discussion and feedback\nBuilding connections with fellow developers\nContributing to the broader tech community"
  },
  {
    "objectID": "blog.html#upcoming-posts",
    "href": "blog.html#upcoming-posts",
    "title": "Blog",
    "section": "",
    "text": "“Building a Scalable Web Application: Lessons Learned”\n“My Kubernetes Learning Journey: From Docker to Orchestration”\n“Technical Blog Analysis: Uber’s Real-time Data Platform”\n“Book Review: Designing Data-Intensive Applications”\n“DSA Interview Preparation: My 3-Month Plan”\n\n\n\n\n\n“System Design Deep Dive”: Multi-part series on scalable architecture\n“DSA Problem Patterns”: Common algorithmic patterns and solutions\n“Technical Blog Analysis”: Regular breakdowns of engineering articles\n“Learning Path Guides”: Structured learning recommendations"
  },
  {
    "objectID": "blog.html#guest-posts-collaboration",
    "href": "blog.html#guest-posts-collaboration",
    "title": "Blog",
    "section": "",
    "text": "I welcome guest posts from other developers and learners. If you’d like to contribute:\n\nTopic Ideas: Share your expertise and experiences\nTechnical Tutorials: Step-by-step guides and walkthroughs\nCase Studies: Real-world project experiences\nLearning Journeys: Your own path to mastering concepts\n\n\n\n\n\nJoint Posts: Co-author articles on complex topics\nInterview Series: Q&A with experienced developers\nStudy Groups: Collaborative learning content\nProject Showcases: Highlighting community projects"
  },
  {
    "objectID": "blog.html#blog-statistics",
    "href": "blog.html#blog-statistics",
    "title": "Blog",
    "section": "",
    "text": "Total Posts: 15+ articles\nMonthly Views: Growing steadily\nEngagement: Active discussions in comments\nTopics Covered: DSA, System Design, Technical Blogs, Books\n\n\n\n\n\nComments: Thoughtful discussions on technical topics\nSocial Shares: Content shared across developer communities\nFeedback: Valuable insights from readers\nQuestions: Technical questions and clarifications"
  },
  {
    "objectID": "blog.html#reading-recommendations",
    "href": "blog.html#reading-recommendations",
    "title": "Blog",
    "section": "",
    "text": "Start with the “Learning Path Guides” series\nFocus on fundamental DSA concepts\nBuild a strong foundation before diving into advanced topics\n\n\n\n\n\nExplore system design patterns and case studies\nPractice with the provided code examples\nEngage in discussions and share your experiences\n\n\n\n\n\nContribute guest posts and share your expertise\nProvide feedback and suggestions for improvement\nMentor others in their learning journey"
  },
  {
    "objectID": "blog.html#stay-connected",
    "href": "blog.html#stay-connected",
    "title": "Blog",
    "section": "",
    "text": "Subscribe to get notified about new posts and learning updates:\nSubscribe to Newsletter\n\n\n\n\nTwitter: @yourhandle - Quick thoughts and updates\nLinkedIn: Your Profile - Professional insights\nGitHub: Your Profile - Code examples and projects\n\n\n\n\nGet updates via RSS: RSS Feed"
  },
  {
    "objectID": "blog.html#blogging-goals",
    "href": "blog.html#blogging-goals",
    "title": "Blog",
    "section": "",
    "text": "Publish Frequency: 2-3 posts per month\nContent Quality: In-depth, well-researched articles\nCommunity Engagement: Active discussions and feedback\nSkill Development: Improve writing and communication\n\n\n\n\n\nThought Leadership: Establish expertise in key areas\nCommunity Building: Create a learning-focused community\nKnowledge Sharing: Help others in their learning journey\nProfessional Growth: Build a strong personal brand\n\n\n\n\n\n\n\nWriting Tips for Developers\n\n\n\n\nStart with an outline: Plan your post structure before writing\nInclude code examples: Show, don’t just tell\nUse clear explanations: Break down complex concepts\nEngage with readers: Encourage comments and discussion\nBe consistent: Regular posting builds audience\n\n\n\n\n\n\n\n\n\nCommon Blogging Mistakes\n\n\n\n\nToo much theory: Balance with practical examples\nPoor formatting: Use headers, lists, and code blocks\nNo engagement: Respond to comments and questions\nInconsistent posting: Maintain regular schedule"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hello 👋 I’m Rohit Kumar, a technology enthusiast with a deep love for programming and a passion for continuous learning. I’ve recently discovered my interest in tech blogging and writing, and I’m enthusiastic about sharing insights and knowledge from the ever-evolving world of technology.\n\n\n\nI’m a software developer passionate about continuous learning and sharing knowledge. This wiki serves as my digital garden where I document my learning journey, organize technical knowledge, and share insights with the developer community.\n\n\n\n\n\nThis wiki tracks my progress through four main areas of software development: - Data Structures & Algorithms: Core computer science fundamentals - System Design: Scalable architecture and distributed systems - Technical Blogs: Analysis of engineering articles and insights - Books: Reading notes and summaries from technical literature\n\n\n\nA comprehensive collection of: - Code Examples: Practical implementations and solutions - Architecture Patterns: System design principles and trade-offs - Best Practices: Industry standards and proven approaches - Learning Resources: Curated materials and references\n\n\n\nA living document that: - Grows Over Time: New content added regularly - Connects Ideas: Links between related concepts - Evolves: Content updated as my understanding deepens - Shares Knowledge: Open for others to learn from\n\n\n\n\nBachelors in Mechanical Engineering - [2020 - 2024]\nNational Institute of Technology, Warangal, India\nCGPA: 7.34 / 10\n\n\n\nObject-Oriented Programming using Java\nData Structure and Algorithms\nNumerical and Statistical Methods\nLinear Algebra & Calculus\n\n\n\n\n\n\n\n\nDeveloped and implemented a “Copy Data” button using JavaScript, Oracle JavaScript Extension Toolkit (OJET), and Visual Builder Cloud Service (VBCS). The button facilitated the copying of data for lead time columns, streamlining the process for the Supply Planning Team.\nUtilized ElasticSearch REST endpoints to efficiently bind data to tables, ensuring seamless data retrieval and display in the application.\nImplemented data update functionality using PATCH requests, enabling real-time and incremental updates for changed data in the application.\nDemonstrated proficiency in data analysis and visualization by incorporating Trendline functionality in OJET charts using Linear Regression. This addition allowed for trend identification and better data-driven decision-making.\n\n\n\n\n\n\nConducted 15+ Competitive Programming Contests for Students along with Discussions\nQualified Internal Round for Smart India Hackathon 2022\n600+ problems solved on LeetCode, Geeks for Geeks, CodeChef, CodeForces etc.\n\n\n\n\n\n\n\nJava: Object-Oriented Programming and backend development\nJavaScript: Web development and Oracle VBCS\nPython: Algorithms, data science, and machine learning\nReact/NextJS: Currently learning modern web development\nSQL: Database design and optimization\n\n\n\n\n\nGit: Version control and collaboration\nOracle VBCS: Cloud application development\nElasticSearch: Data search and analytics\nOJET: Oracle JavaScript Extension Toolkit\n\n\n\n\n\nCompetitive Programming: 600+ problems solved across platforms\nWeb Development: Learning React and NextJS\nOpen Source: Exploring and contributing to projects\nMachine Learning: Exploring AI/ML technologies\n\n\n\n\n\nI’m always interested in connecting with other developers and learners. Here are some ways to reach out:\n\n\n\nGitHub: kmr-rohit\nLinkedIn: Rohit Kumar\nLeetCode: Rohit Kumar\n\nThis wiki is a work in progress, constantly evolving as I learn and grow. Thank you for being part of this journey!\n\n\n\n\n\n\nStart Your Own Learning Journey\n\n\n\n\nChoose a Focus: Pick an area that interests you\nSet Goals: Define what you want to achieve\nCreate Structure: Organize your learning systematically\nShare Progress: Document and share your journey\nStay Consistent: Make learning a regular habit"
  },
  {
    "objectID": "about.html#who-i-am",
    "href": "about.html#who-i-am",
    "title": "About",
    "section": "",
    "text": "I’m a software developer passionate about continuous learning and sharing knowledge. This wiki serves as my digital garden where I document my learning journey, organize technical knowledge, and share insights with the developer community."
  },
  {
    "objectID": "about.html#what-this-wiki-is",
    "href": "about.html#what-this-wiki-is",
    "title": "About",
    "section": "",
    "text": "This wiki tracks my progress through four main areas of software development: - Data Structures & Algorithms: Core computer science fundamentals - System Design: Scalable architecture and distributed systems - Technical Blogs: Analysis of engineering articles and insights - Books: Reading notes and summaries from technical literature\n\n\n\nA comprehensive collection of: - Code Examples: Practical implementations and solutions - Architecture Patterns: System design principles and trade-offs - Best Practices: Industry standards and proven approaches - Learning Resources: Curated materials and references\n\n\n\nA living document that: - Grows Over Time: New content added regularly - Connects Ideas: Links between related concepts - Evolves: Content updated as my understanding deepens - Shares Knowledge: Open for others to learn from"
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About",
    "section": "",
    "text": "Bachelors in Mechanical Engineering - [2020 - 2024]\nNational Institute of Technology, Warangal, India\nCGPA: 7.34 / 10\n\n\n\nObject-Oriented Programming using Java\nData Structure and Algorithms\nNumerical and Statistical Methods\nLinear Algebra & Calculus"
  },
  {
    "objectID": "about.html#work-experience",
    "href": "about.html#work-experience",
    "title": "About",
    "section": "",
    "text": "Developed and implemented a “Copy Data” button using JavaScript, Oracle JavaScript Extension Toolkit (OJET), and Visual Builder Cloud Service (VBCS). The button facilitated the copying of data for lead time columns, streamlining the process for the Supply Planning Team.\nUtilized ElasticSearch REST endpoints to efficiently bind data to tables, ensuring seamless data retrieval and display in the application.\nImplemented data update functionality using PATCH requests, enabling real-time and incremental updates for changed data in the application.\nDemonstrated proficiency in data analysis and visualization by incorporating Trendline functionality in OJET charts using Linear Regression. This addition allowed for trend identification and better data-driven decision-making."
  },
  {
    "objectID": "about.html#achievements",
    "href": "about.html#achievements",
    "title": "About",
    "section": "",
    "text": "Conducted 15+ Competitive Programming Contests for Students along with Discussions\nQualified Internal Round for Smart India Hackathon 2022\n600+ problems solved on LeetCode, Geeks for Geeks, CodeChef, CodeForces etc."
  },
  {
    "objectID": "about.html#technology-stack",
    "href": "about.html#technology-stack",
    "title": "About",
    "section": "",
    "text": "Java: Object-Oriented Programming and backend development\nJavaScript: Web development and Oracle VBCS\nPython: Algorithms, data science, and machine learning\nReact/NextJS: Currently learning modern web development\nSQL: Database design and optimization\n\n\n\n\n\nGit: Version control and collaboration\nOracle VBCS: Cloud application development\nElasticSearch: Data search and analytics\nOJET: Oracle JavaScript Extension Toolkit\n\n\n\n\n\nCompetitive Programming: 600+ problems solved across platforms\nWeb Development: Learning React and NextJS\nOpen Source: Exploring and contributing to projects\nMachine Learning: Exploring AI/ML technologies"
  },
  {
    "objectID": "about.html#get-in-touch",
    "href": "about.html#get-in-touch",
    "title": "About",
    "section": "",
    "text": "I’m always interested in connecting with other developers and learners. Here are some ways to reach out:\n\n\n\nGitHub: kmr-rohit\nLinkedIn: Rohit Kumar\nLeetCode: Rohit Kumar\n\nThis wiki is a work in progress, constantly evolving as I learn and grow. Thank you for being part of this journey!\n\n\n\n\n\n\nStart Your Own Learning Journey\n\n\n\n\nChoose a Focus: Pick an area that interests you\nSet Goals: Define what you want to achieve\nCreate Structure: Organize your learning systematically\nShare Progress: Document and share your journey\nStay Consistent: Make learning a regular habit"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Developer Learning Wiki",
    "section": "",
    "text": "Your journey to becoming a better software developer\n\n\n\n\n\n\nSoftware DeveloperLearning Journey & Knowledge BaseContinuous Growth\n\n \n\nBlog ⸱ GitHub ⸱ LinkedIn ⸱ About\n\n \n\nWelcome to my learning journey as a software developer. This wiki serves as my personal knowledge base covering four main areas: Data Structures & Algorithms, System Design, Technical Blog Breakdowns, and Book Notes.\n\n \n\n\n\n\n\nCore computer science fundamentals, problem-solving techniques, and algorithmic thinking.\n\n\n\nScalable architecture patterns, distributed systems, and real-world system design challenges.\n\n\n\nBreakdowns and notes from technical articles, engineering blogs, and industry insights.\n\n\n\nReading notes, summaries, and key takeaways from technical books and resources."
  },
  {
    "objectID": "index.html#learning-areas",
    "href": "index.html#learning-areas",
    "title": "Developer Learning Wiki",
    "section": "",
    "text": "Core computer science fundamentals, problem-solving techniques, and algorithmic thinking.\n\n\n\nScalable architecture patterns, distributed systems, and real-world system design challenges.\n\n\n\nBreakdowns and notes from technical articles, engineering blogs, and industry insights.\n\n\n\nReading notes, summaries, and key takeaways from technical books and resources."
  },
  {
    "objectID": "index.html#latest-blog-posts",
    "href": "index.html#latest-blog-posts",
    "title": "Developer Learning Wiki",
    "section": "Latest Blog Posts",
    "text": "Latest Blog Posts\n\n\n\n\n15 Mar, 2024\nMy System Design Learning Path\nSystem Design Learning\n\n\n\nNo matching items\n\nAll Posts"
  },
  {
    "objectID": "books/reading-list/index.html",
    "href": "books/reading-list/index.html",
    "title": "Reading List",
    "section": "",
    "text": "A curated collection of essential books for software developers and system designers.\n\n\n\nDesigning Data-Intensive Applications - Martin Kleppmann\nSystem Design Interview - Alex Xu\nBuilding Microservices - Sam Newman\nDomain-Driven Design - Eric Evans\nClean Architecture - Robert C. Martin\n\n\n\n\n\nDatabase Internals - Alex Petrov\nDesigning Data-Intensive Applications - Martin Kleppmann\nHigh Performance MySQL - Baron Schwartz\nRedis in Action - Josiah L. Carlson\nThe Data Warehouse Toolkit - Ralph Kimball\n\n\n\n\n\nClean Code - Robert C. Martin\nRefactoring - Martin Fowler\nDesign Patterns - Gang of Four\nEffective Java - Joshua Bloch\nPython Cookbook - David Beazley\n\n\n\n\n\nIntroduction to Algorithms - CLRS\nAlgorithms - Robert Sedgewick\nProgramming Pearls - Jon Bentley\nThe Algorithm Design Manual - Steven Skiena\n\n\n\n\n\nComputer Networks - Andrew Tanenbaum\nOperating Systems - Andrew Tanenbaum\nComputer Architecture - Hennessy & Patterson\nCompilers - Aho, Lam, Sethi, Ullman\n\n\n\n\n\nSite Reliability Engineering - Google\nThe Phoenix Project - Gene Kim\nKubernetes in Action - Marko Lukša\nInfrastructure as Code - Kief Morris\n\n\n\n\n\nSecurity Engineering - Ross Anderson\nWeb Application Security - Andrew van der Stock\nCryptography Engineering - Ferguson, Schneier, Kohno\nThe Art of Deception - Kevin Mitnick\n\n\n\n\n\nDesigning Machine Learning Systems - Chip Huyen\nHands-On Machine Learning - Aurélien Géron\nPattern Recognition - Bishop\nDeep Learning - Ian Goodfellow\n\n\n\n\n\nThe Pragmatic Programmer - Hunt & Thomas\nSoft Skills - John Sonmez\nCracking the Coding Interview - Gayle McDowell\nThe Manager’s Path - Camille Fournier\n\n\n\n\n\n\n\nEssential - Must read for every developer\nImportant - Highly recommended for career growth\nSpecialized - Domain-specific knowledge\nReference - Keep for consultation\n\n\n\n\n\nStart with fundamentals (algorithms, data structures)\nMove to software engineering practices\nLearn system design and architecture\nSpecialize in your domain of interest\n\n\n\n\n\nUse active reading techniques\nTake notes in your own words\nCreate summaries and mind maps\nImplement concepts in code\nDiscuss with peers",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/reading-list/index.html#system-design-architecture",
    "href": "books/reading-list/index.html#system-design-architecture",
    "title": "Reading List",
    "section": "",
    "text": "Designing Data-Intensive Applications - Martin Kleppmann\nSystem Design Interview - Alex Xu\nBuilding Microservices - Sam Newman\nDomain-Driven Design - Eric Evans\nClean Architecture - Robert C. Martin",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/reading-list/index.html#database-data-engineering",
    "href": "books/reading-list/index.html#database-data-engineering",
    "title": "Reading List",
    "section": "",
    "text": "Database Internals - Alex Petrov\nDesigning Data-Intensive Applications - Martin Kleppmann\nHigh Performance MySQL - Baron Schwartz\nRedis in Action - Josiah L. Carlson\nThe Data Warehouse Toolkit - Ralph Kimball",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/reading-list/index.html#programming-software-engineering",
    "href": "books/reading-list/index.html#programming-software-engineering",
    "title": "Reading List",
    "section": "",
    "text": "Clean Code - Robert C. Martin\nRefactoring - Martin Fowler\nDesign Patterns - Gang of Four\nEffective Java - Joshua Bloch\nPython Cookbook - David Beazley",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/reading-list/index.html#algorithms-data-structures",
    "href": "books/reading-list/index.html#algorithms-data-structures",
    "title": "Reading List",
    "section": "",
    "text": "Introduction to Algorithms - CLRS\nAlgorithms - Robert Sedgewick\nProgramming Pearls - Jon Bentley\nThe Algorithm Design Manual - Steven Skiena",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/reading-list/index.html#computer-science-fundamentals",
    "href": "books/reading-list/index.html#computer-science-fundamentals",
    "title": "Reading List",
    "section": "",
    "text": "Computer Networks - Andrew Tanenbaum\nOperating Systems - Andrew Tanenbaum\nComputer Architecture - Hennessy & Patterson\nCompilers - Aho, Lam, Sethi, Ullman",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/reading-list/index.html#devops-infrastructure",
    "href": "books/reading-list/index.html#devops-infrastructure",
    "title": "Reading List",
    "section": "",
    "text": "Site Reliability Engineering - Google\nThe Phoenix Project - Gene Kim\nKubernetes in Action - Marko Lukša\nInfrastructure as Code - Kief Morris",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/reading-list/index.html#security",
    "href": "books/reading-list/index.html#security",
    "title": "Reading List",
    "section": "",
    "text": "Security Engineering - Ross Anderson\nWeb Application Security - Andrew van der Stock\nCryptography Engineering - Ferguson, Schneier, Kohno\nThe Art of Deception - Kevin Mitnick",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/reading-list/index.html#machine-learning-ai",
    "href": "books/reading-list/index.html#machine-learning-ai",
    "title": "Reading List",
    "section": "",
    "text": "Designing Machine Learning Systems - Chip Huyen\nHands-On Machine Learning - Aurélien Géron\nPattern Recognition - Bishop\nDeep Learning - Ian Goodfellow",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/reading-list/index.html#career-soft-skills",
    "href": "books/reading-list/index.html#career-soft-skills",
    "title": "Reading List",
    "section": "",
    "text": "The Pragmatic Programmer - Hunt & Thomas\nSoft Skills - John Sonmez\nCracking the Coding Interview - Gayle McDowell\nThe Manager’s Path - Camille Fournier",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/reading-list/index.html#reading-strategy",
    "href": "books/reading-list/index.html#reading-strategy",
    "title": "Reading List",
    "section": "",
    "text": "Essential - Must read for every developer\nImportant - Highly recommended for career growth\nSpecialized - Domain-specific knowledge\nReference - Keep for consultation\n\n\n\n\n\nStart with fundamentals (algorithms, data structures)\nMove to software engineering practices\nLearn system design and architecture\nSpecialize in your domain of interest\n\n\n\n\n\nUse active reading techniques\nTake notes in your own words\nCreate summaries and mind maps\nImplement concepts in code\nDiscuss with peers",
    "crumbs": [
      "Books",
      "Reading List"
    ]
  },
  {
    "objectID": "books/notes.html",
    "href": "books/notes.html",
    "title": "Book Notes",
    "section": "",
    "text": "Detailed notes and summaries from my technical book readings.\n\n\n\n\nProgress: 60% (Chapter 5: Replication)\nCategory: System Design\nRating: ⭐⭐⭐⭐⭐ (so far)\n\n\nKey Concepts: - Reliability: System continues working correctly despite faults - Scalability: System can handle increased load gracefully - Maintainability: System can be modified and operated easily\nImportant Points: - Faults vs Failures: Faults are component failures, failures are system-wide - Scalability Metrics: Throughput (requests/second) and response time - Maintainability Factors: Operability, simplicity, evolvability\nCode Example:\n# Example: Fault-tolerant service\nclass FaultTolerantService:\n    def __init__(self, primary_service, backup_service):\n        self.primary = primary_service\n        self.backup = backup_service\n        self.current = self.primary\n    \n    def handle_request(self, request):\n        try:\n            return self.current.process(request)\n        except ServiceUnavailableError:\n            # Failover to backup\n            self.current = self.backup\n            return self.current.process(request)\n\n\n\nKey Concepts: - Relational Model: Tables with relationships, SQL queries - Document Model: Self-contained documents, hierarchical data - Graph Model: Entities and relationships, complex queries\nTrade-offs: - Relational: ACID transactions, complex queries, schema flexibility - Document: Schema flexibility, locality, complex queries harder - Graph: Complex relationships, query complexity, scaling challenges\nPractical Application:\n-- Relational: User with multiple addresses\nCREATE TABLE users (\n    id INT PRIMARY KEY,\n    name VARCHAR(100),\n    email VARCHAR(100)\n);\n\nCREATE TABLE addresses (\n    id INT PRIMARY KEY,\n    user_id INT,\n    street VARCHAR(200),\n    city VARCHAR(100),\n    FOREIGN KEY (user_id) REFERENCES users(id)\n);\n\n-- Document: User with embedded addresses\n{\n    \"id\": 123,\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"addresses\": [\n        {\"street\": \"123 Main St\", \"city\": \"New York\"},\n        {\"street\": \"456 Oak Ave\", \"city\": \"Los Angeles\"}\n    ]\n}\n\n\n\nKey Concepts: - B-tree: Balanced tree structure, good for range queries - LSM-tree: Log-structured merge tree, high write throughput - Hash Indexes: Key-value lookups, no range queries\nPerformance Characteristics: - B-tree: O(log n) reads and writes, good for mixed workloads - LSM-tree: O(log n) reads, O(1) writes, write-optimized - Hash Index: O(1) reads and writes, no range queries\nImplementation Example:\n# Simple B-tree implementation concept\nclass BTreeNode:\n    def __init__(self, leaf=True):\n        self.leaf = leaf\n        self.keys = []\n        self.children = []\n        self.values = []\n\nclass BTree:\n    def __init__(self, t=3):\n        self.root = BTreeNode()\n        self.t = t  # minimum degree\n    \n    def search(self, key, node=None):\n        if node is None:\n            node = self.root\n        \n        i = 0\n        while i &lt; len(node.keys) and key &gt; node.keys[i]:\n            i += 1\n        \n        if i &lt; len(node.keys) and node.keys[i] == key:\n            return node.values[i]\n        \n        if node.leaf:\n            return None\n        \n        return self.search(key, node.children[i])\n\n\n\nKey Concepts: - Schema Evolution: Handling data format changes over time - Backward Compatibility: New code can read old data - Forward Compatibility: Old code can read new data\nEncoding Formats: - JSON: Human-readable, schema-less, verbose - Protocol Buffers: Binary, schema-based, efficient - Avro: Schema evolution, binary format\nSchema Evolution Example:\n// Protocol Buffer schema evolution\nmessage User {\n    string id = 1;\n    string name = 2;\n    string email = 3;\n    // New field added - optional for backward compatibility\n    optional string phone = 4;\n}\n\n// Migration strategy\ndef migrate_user_data(old_user, new_schema):\n    new_user = {\n        'id': old_user.get('id'),\n        'name': old_user.get('name'),\n        'email': old_user.get('email'),\n        'phone': old_user.get('phone', '')  # Default value\n    }\n    return new_user\n\n\n\nKey Concepts: - Leader-Follower Replication: Single leader, multiple followers - Multi-Leader Replication: Multiple leaders, conflict resolution - Leaderless Replication: No single leader, quorum-based\nConsistency Models: - Synchronous: Wait for all replicas to confirm - Asynchronous: Don’t wait for replica confirmation - Semi-synchronous: Wait for some replicas\n\n\n\n\n\nProgress: 40% (Arrays & Strings section)\nCategory: DSA\nRating: ⭐⭐⭐⭐⭐\n\n\nKey Techniques: - Two Pointers: Efficient array traversal and manipulation - Sliding Window: Contiguous subarray problems - Hash Tables: O(1) lookups for frequency counting\nCommon Patterns:\n# Two Pointers - Two Sum in sorted array\ndef two_sum_sorted(arr, target):\n    left, right = 0, len(arr) - 1\n    while left &lt; right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum &lt; target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\n# Sliding Window - Longest substring without repeating characters\ndef longest_substring(s):\n    char_map = {}\n    left = 0\n    max_length = 0\n    \n    for right, char in enumerate(s):\n        if char in char_map and char_map[char] &gt;= left:\n            left = char_map[char] + 1\n        char_map[char] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Hash Table - Character frequency\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    \n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    for char in t:\n        if char not in char_count or char_count[char] == 0:\n            return False\n        char_count[char] -= 1\n    \n    return True\n\n\n\nKey Techniques: - Fast/Slow Pointers: Detect cycles, find middle - Reversing: Iterative and recursive approaches - Merging: Combine sorted lists efficiently\nCommon Patterns:\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Fast/Slow Pointers - Detect cycle\ndef has_cycle(head):\n    if not head or not head.next:\n        return False\n    \n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    \n    return False\n\n# Reverse Linked List\ndef reverse_list(head):\n    prev = None\n    curr = head\n    \n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    return prev\n\n# Merge Two Sorted Lists\ndef merge_two_lists(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    \n    while l1 and l2:\n        if l1.val &lt;= l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    \n    current.next = l1 if l1 else l2\n    return dummy.next\n\n\n\n\n\n\n\nCategory: Programming\nRating: ⭐⭐⭐⭐⭐\nCompletion Date: January 2024\n\n\nMeaningful Names: - Use intention-revealing names - Avoid disinformation and abbreviations - Make names pronounceable and searchable - Use consistent naming conventions\nFunctions: - Keep functions small (ideally &lt; 20 lines) - Do one thing well - Use descriptive names - Minimize arguments (0-3 is ideal)\nCode Example:\n# Bad: Unclear names and long function\ndef process_data(data):\n    result = []\n    for item in data:\n        if item['status'] == 'active' and item['age'] &gt; 18:\n            result.append({\n                'name': item['name'],\n                'score': item['score'] * 1.1\n            })\n    return result\n\n# Good: Clear names and small functions\ndef get_eligible_users(users):\n    return [user for user in users if is_eligible(user)]\n\ndef is_eligible(user):\n    return user['status'] == 'active' and user['age'] &gt; 18\n\ndef calculate_bonus_score(user):\n    return {\n        'name': user['name'],\n        'score': user['score'] * BONUS_MULTIPLIER\n    }\n\n\n\nSingle Responsibility Principle (SRP): - A class should have only one reason to change - Each class should have a single, well-defined purpose\nOpen/Closed Principle (OCP): - Open for extension, closed for modification - Use inheritance and polymorphism\nLiskov Substitution Principle (LSP): - Subtypes must be substitutable for their base types - Don’t violate the contract of the base class\nInterface Segregation Principle (ISP): - Clients shouldn’t depend on interfaces they don’t use - Keep interfaces small and focused\nDependency Inversion Principle (DIP): - Depend on abstractions, not concretions - High-level modules shouldn’t depend on low-level modules\n\n\n\n\nCategory: Programming\nRating: ⭐⭐⭐⭐⭐\nCompletion Date: February 2024\n\n\nDRY (Don’t Repeat Yourself): - Every piece of knowledge should have a single representation - Eliminate duplication in code, documentation, and processes\nAutomation: - Automate repetitive tasks - Use scripts for build, test, and deployment - Invest in tools that save time\nCode Example:\n# Automation example: Build script\n#!/usr/bin/env python3\nimport subprocess\nimport sys\n\ndef run_tests():\n    \"\"\"Run all tests and return success status\"\"\"\n    result = subprocess.run(['python', '-m', 'pytest'], capture_output=True)\n    return result.returncode == 0\n\ndef build_project():\n    \"\"\"Build the project\"\"\"\n    subprocess.run(['python', 'setup.py', 'build'])\n\ndef main():\n    print(\"Running tests...\")\n    if not run_tests():\n        print(\"Tests failed!\")\n        sys.exit(1)\n    \n    print(\"Building project...\")\n    build_project()\n    print(\"Build complete!\")\n\nif __name__ == \"__main__\":\n    main()\n\n\n\nOrthogonality: - Keep components independent - Changes in one component shouldn’t affect others - Use loose coupling and high cohesion\nPrototyping: - Build prototypes to explore ideas - Use prototypes to validate assumptions - Throw away prototypes, don’t evolve them into production\nTesting: - Test early, test often, test automatically - Write tests for your code - Use test-driven development (TDD)\n\n\n\n\n\n\n\n## Book: [Title]\n**Author**: [Author Name]  \n**Category**: [DSA/System Design/Programming/etc.]  \n**Status**: [Reading/Completed/Planned]  \n**Rating**: [1-5 stars]\n\n### Summary\n[2-3 sentence overview of the book]\n\n### Key Concepts\n- [Concept 1 with explanation]\n- [Concept 2 with explanation]\n- [Concept 3 with explanation]\n\n### Code Examples\n[Important code snippets and implementations]\n\n### Practical Applications\n[How to apply concepts in real projects]\n\n### Questions & Follow-up\n[Topics to explore further]\n\n### Chapter-by-Chapter Notes\n\n#### Chapter 1: [Title]\n**Key Points**:\n- [Point 1]\n- [Point 2]\n- [Point 3]\n\n**Code Examples**:\n```python\n# Example code here\nQuestions: - [Question 1] - [Question 2] ```\n\n\n\n\n\n\n\n\n\nEffective Note-Taking\n\n\n\n\nBe Selective: Focus on key concepts and insights\nUse Your Own Words: Don’t just copy, understand and rephrase\nInclude Examples: Code snippets and practical applications\nAsk Questions: Note areas that need further exploration\nConnect Ideas: Link concepts to other books and experiences\n\n\n\n\n\n\n\n\n\nCommon Mistakes\n\n\n\n\nPassive Copying: Just copying text without understanding\nToo Much Detail: Getting lost in minutiae\nNo Review: Writing notes but never revisiting them\nNo Application: Not connecting theory to practice",
    "crumbs": [
      "Books",
      "Book Notes"
    ]
  },
  {
    "objectID": "books/notes.html#currently-reading",
    "href": "books/notes.html#currently-reading",
    "title": "Book Notes",
    "section": "",
    "text": "Progress: 60% (Chapter 5: Replication)\nCategory: System Design\nRating: ⭐⭐⭐⭐⭐ (so far)\n\n\nKey Concepts: - Reliability: System continues working correctly despite faults - Scalability: System can handle increased load gracefully - Maintainability: System can be modified and operated easily\nImportant Points: - Faults vs Failures: Faults are component failures, failures are system-wide - Scalability Metrics: Throughput (requests/second) and response time - Maintainability Factors: Operability, simplicity, evolvability\nCode Example:\n# Example: Fault-tolerant service\nclass FaultTolerantService:\n    def __init__(self, primary_service, backup_service):\n        self.primary = primary_service\n        self.backup = backup_service\n        self.current = self.primary\n    \n    def handle_request(self, request):\n        try:\n            return self.current.process(request)\n        except ServiceUnavailableError:\n            # Failover to backup\n            self.current = self.backup\n            return self.current.process(request)\n\n\n\nKey Concepts: - Relational Model: Tables with relationships, SQL queries - Document Model: Self-contained documents, hierarchical data - Graph Model: Entities and relationships, complex queries\nTrade-offs: - Relational: ACID transactions, complex queries, schema flexibility - Document: Schema flexibility, locality, complex queries harder - Graph: Complex relationships, query complexity, scaling challenges\nPractical Application:\n-- Relational: User with multiple addresses\nCREATE TABLE users (\n    id INT PRIMARY KEY,\n    name VARCHAR(100),\n    email VARCHAR(100)\n);\n\nCREATE TABLE addresses (\n    id INT PRIMARY KEY,\n    user_id INT,\n    street VARCHAR(200),\n    city VARCHAR(100),\n    FOREIGN KEY (user_id) REFERENCES users(id)\n);\n\n-- Document: User with embedded addresses\n{\n    \"id\": 123,\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"addresses\": [\n        {\"street\": \"123 Main St\", \"city\": \"New York\"},\n        {\"street\": \"456 Oak Ave\", \"city\": \"Los Angeles\"}\n    ]\n}\n\n\n\nKey Concepts: - B-tree: Balanced tree structure, good for range queries - LSM-tree: Log-structured merge tree, high write throughput - Hash Indexes: Key-value lookups, no range queries\nPerformance Characteristics: - B-tree: O(log n) reads and writes, good for mixed workloads - LSM-tree: O(log n) reads, O(1) writes, write-optimized - Hash Index: O(1) reads and writes, no range queries\nImplementation Example:\n# Simple B-tree implementation concept\nclass BTreeNode:\n    def __init__(self, leaf=True):\n        self.leaf = leaf\n        self.keys = []\n        self.children = []\n        self.values = []\n\nclass BTree:\n    def __init__(self, t=3):\n        self.root = BTreeNode()\n        self.t = t  # minimum degree\n    \n    def search(self, key, node=None):\n        if node is None:\n            node = self.root\n        \n        i = 0\n        while i &lt; len(node.keys) and key &gt; node.keys[i]:\n            i += 1\n        \n        if i &lt; len(node.keys) and node.keys[i] == key:\n            return node.values[i]\n        \n        if node.leaf:\n            return None\n        \n        return self.search(key, node.children[i])\n\n\n\nKey Concepts: - Schema Evolution: Handling data format changes over time - Backward Compatibility: New code can read old data - Forward Compatibility: Old code can read new data\nEncoding Formats: - JSON: Human-readable, schema-less, verbose - Protocol Buffers: Binary, schema-based, efficient - Avro: Schema evolution, binary format\nSchema Evolution Example:\n// Protocol Buffer schema evolution\nmessage User {\n    string id = 1;\n    string name = 2;\n    string email = 3;\n    // New field added - optional for backward compatibility\n    optional string phone = 4;\n}\n\n// Migration strategy\ndef migrate_user_data(old_user, new_schema):\n    new_user = {\n        'id': old_user.get('id'),\n        'name': old_user.get('name'),\n        'email': old_user.get('email'),\n        'phone': old_user.get('phone', '')  # Default value\n    }\n    return new_user\n\n\n\nKey Concepts: - Leader-Follower Replication: Single leader, multiple followers - Multi-Leader Replication: Multiple leaders, conflict resolution - Leaderless Replication: No single leader, quorum-based\nConsistency Models: - Synchronous: Wait for all replicas to confirm - Asynchronous: Don’t wait for replica confirmation - Semi-synchronous: Wait for some replicas\n\n\n\n\n\nProgress: 40% (Arrays & Strings section)\nCategory: DSA\nRating: ⭐⭐⭐⭐⭐\n\n\nKey Techniques: - Two Pointers: Efficient array traversal and manipulation - Sliding Window: Contiguous subarray problems - Hash Tables: O(1) lookups for frequency counting\nCommon Patterns:\n# Two Pointers - Two Sum in sorted array\ndef two_sum_sorted(arr, target):\n    left, right = 0, len(arr) - 1\n    while left &lt; right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum &lt; target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\n# Sliding Window - Longest substring without repeating characters\ndef longest_substring(s):\n    char_map = {}\n    left = 0\n    max_length = 0\n    \n    for right, char in enumerate(s):\n        if char in char_map and char_map[char] &gt;= left:\n            left = char_map[char] + 1\n        char_map[char] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Hash Table - Character frequency\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    \n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    for char in t:\n        if char not in char_count or char_count[char] == 0:\n            return False\n        char_count[char] -= 1\n    \n    return True\n\n\n\nKey Techniques: - Fast/Slow Pointers: Detect cycles, find middle - Reversing: Iterative and recursive approaches - Merging: Combine sorted lists efficiently\nCommon Patterns:\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Fast/Slow Pointers - Detect cycle\ndef has_cycle(head):\n    if not head or not head.next:\n        return False\n    \n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    \n    return False\n\n# Reverse Linked List\ndef reverse_list(head):\n    prev = None\n    curr = head\n    \n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    return prev\n\n# Merge Two Sorted Lists\ndef merge_two_lists(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    \n    while l1 and l2:\n        if l1.val &lt;= l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    \n    current.next = l1 if l1 else l2\n    return dummy.next",
    "crumbs": [
      "Books",
      "Book Notes"
    ]
  },
  {
    "objectID": "books/notes.html#completed-books",
    "href": "books/notes.html#completed-books",
    "title": "Book Notes",
    "section": "",
    "text": "Category: Programming\nRating: ⭐⭐⭐⭐⭐\nCompletion Date: January 2024\n\n\nMeaningful Names: - Use intention-revealing names - Avoid disinformation and abbreviations - Make names pronounceable and searchable - Use consistent naming conventions\nFunctions: - Keep functions small (ideally &lt; 20 lines) - Do one thing well - Use descriptive names - Minimize arguments (0-3 is ideal)\nCode Example:\n# Bad: Unclear names and long function\ndef process_data(data):\n    result = []\n    for item in data:\n        if item['status'] == 'active' and item['age'] &gt; 18:\n            result.append({\n                'name': item['name'],\n                'score': item['score'] * 1.1\n            })\n    return result\n\n# Good: Clear names and small functions\ndef get_eligible_users(users):\n    return [user for user in users if is_eligible(user)]\n\ndef is_eligible(user):\n    return user['status'] == 'active' and user['age'] &gt; 18\n\ndef calculate_bonus_score(user):\n    return {\n        'name': user['name'],\n        'score': user['score'] * BONUS_MULTIPLIER\n    }\n\n\n\nSingle Responsibility Principle (SRP): - A class should have only one reason to change - Each class should have a single, well-defined purpose\nOpen/Closed Principle (OCP): - Open for extension, closed for modification - Use inheritance and polymorphism\nLiskov Substitution Principle (LSP): - Subtypes must be substitutable for their base types - Don’t violate the contract of the base class\nInterface Segregation Principle (ISP): - Clients shouldn’t depend on interfaces they don’t use - Keep interfaces small and focused\nDependency Inversion Principle (DIP): - Depend on abstractions, not concretions - High-level modules shouldn’t depend on low-level modules\n\n\n\n\nCategory: Programming\nRating: ⭐⭐⭐⭐⭐\nCompletion Date: February 2024\n\n\nDRY (Don’t Repeat Yourself): - Every piece of knowledge should have a single representation - Eliminate duplication in code, documentation, and processes\nAutomation: - Automate repetitive tasks - Use scripts for build, test, and deployment - Invest in tools that save time\nCode Example:\n# Automation example: Build script\n#!/usr/bin/env python3\nimport subprocess\nimport sys\n\ndef run_tests():\n    \"\"\"Run all tests and return success status\"\"\"\n    result = subprocess.run(['python', '-m', 'pytest'], capture_output=True)\n    return result.returncode == 0\n\ndef build_project():\n    \"\"\"Build the project\"\"\"\n    subprocess.run(['python', 'setup.py', 'build'])\n\ndef main():\n    print(\"Running tests...\")\n    if not run_tests():\n        print(\"Tests failed!\")\n        sys.exit(1)\n    \n    print(\"Building project...\")\n    build_project()\n    print(\"Build complete!\")\n\nif __name__ == \"__main__\":\n    main()\n\n\n\nOrthogonality: - Keep components independent - Changes in one component shouldn’t affect others - Use loose coupling and high cohesion\nPrototyping: - Build prototypes to explore ideas - Use prototypes to validate assumptions - Throw away prototypes, don’t evolve them into production\nTesting: - Test early, test often, test automatically - Write tests for your code - Use test-driven development (TDD)",
    "crumbs": [
      "Books",
      "Book Notes"
    ]
  },
  {
    "objectID": "books/notes.html#reading-notes-template",
    "href": "books/notes.html#reading-notes-template",
    "title": "Book Notes",
    "section": "",
    "text": "## Book: [Title]\n**Author**: [Author Name]  \n**Category**: [DSA/System Design/Programming/etc.]  \n**Status**: [Reading/Completed/Planned]  \n**Rating**: [1-5 stars]\n\n### Summary\n[2-3 sentence overview of the book]\n\n### Key Concepts\n- [Concept 1 with explanation]\n- [Concept 2 with explanation]\n- [Concept 3 with explanation]\n\n### Code Examples\n[Important code snippets and implementations]\n\n### Practical Applications\n[How to apply concepts in real projects]\n\n### Questions & Follow-up\n[Topics to explore further]\n\n### Chapter-by-Chapter Notes\n\n#### Chapter 1: [Title]\n**Key Points**:\n- [Point 1]\n- [Point 2]\n- [Point 3]\n\n**Code Examples**:\n```python\n# Example code here\nQuestions: - [Question 1] - [Question 2] ```\n\n\n\n\n\n\n\n\n\nEffective Note-Taking\n\n\n\n\nBe Selective: Focus on key concepts and insights\nUse Your Own Words: Don’t just copy, understand and rephrase\nInclude Examples: Code snippets and practical applications\nAsk Questions: Note areas that need further exploration\nConnect Ideas: Link concepts to other books and experiences\n\n\n\n\n\n\n\n\n\nCommon Mistakes\n\n\n\n\nPassive Copying: Just copying text without understanding\nToo Much Detail: Getting lost in minutiae\nNo Review: Writing notes but never revisiting them\nNo Application: Not connecting theory to practice",
    "crumbs": [
      "Books",
      "Book Notes"
    ]
  },
  {
    "objectID": "dsa/problems/longest-substring.html",
    "href": "dsa/problems/longest-substring.html",
    "title": "Longest Substring Without Repeating Characters",
    "section": "",
    "text": "Problem: Given a string s, find the length of the longest substring without repeating characters.\n\n\ndef length_of_longest_substring(s):\n    char_map = {}\n    left = 0\n    max_length = 0\n    \n    for right, char in enumerate(s):\n        if char in char_map and char_map[char] &gt;= left:\n            left = char_map[char] + 1\n        char_map[char] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Example\nprint(length_of_longest_substring(\"abcabcbb\"))  # 3\nprint(length_of_longest_substring(\"bbbbb\"))     # 1\nprint(length_of_longest_substring(\"pwwkew\"))    # 3\n\n\n\nTime Complexity: O(n)\nSpace Complexity: O(min(m, n)) where m is charset size\n\n\n\n\nSliding Window: Use two pointers to maintain a window\nHash Map: Track the last position of each character\nUpdate Window: Move left pointer when duplicate is found\nTrack Maximum: Keep track of the longest valid substring\n\n\n\n\n\nEmpty string\nSingle character\nAll characters are the same\nNo repeating characters\nUnicode characters\n\n\n\n\n\nLongest Substring with At Most K Distinct Characters: Allow k different characters\nLongest Substring with At Most Two Distinct Characters: Special case of above\nMinimum Window Substring: Find shortest substring containing all characters from another string",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Longest Substring Without Repeating Characters"
    ]
  },
  {
    "objectID": "dsa/problems/longest-substring.html#solution",
    "href": "dsa/problems/longest-substring.html#solution",
    "title": "Longest Substring Without Repeating Characters",
    "section": "",
    "text": "def length_of_longest_substring(s):\n    char_map = {}\n    left = 0\n    max_length = 0\n    \n    for right, char in enumerate(s):\n        if char in char_map and char_map[char] &gt;= left:\n            left = char_map[char] + 1\n        char_map[char] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Example\nprint(length_of_longest_substring(\"abcabcbb\"))  # 3\nprint(length_of_longest_substring(\"bbbbb\"))     # 1\nprint(length_of_longest_substring(\"pwwkew\"))    # 3",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Longest Substring Without Repeating Characters"
    ]
  },
  {
    "objectID": "dsa/problems/longest-substring.html#analysis",
    "href": "dsa/problems/longest-substring.html#analysis",
    "title": "Longest Substring Without Repeating Characters",
    "section": "",
    "text": "Time Complexity: O(n)\nSpace Complexity: O(min(m, n)) where m is charset size",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Longest Substring Without Repeating Characters"
    ]
  },
  {
    "objectID": "dsa/problems/longest-substring.html#approach",
    "href": "dsa/problems/longest-substring.html#approach",
    "title": "Longest Substring Without Repeating Characters",
    "section": "",
    "text": "Sliding Window: Use two pointers to maintain a window\nHash Map: Track the last position of each character\nUpdate Window: Move left pointer when duplicate is found\nTrack Maximum: Keep track of the longest valid substring",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Longest Substring Without Repeating Characters"
    ]
  },
  {
    "objectID": "dsa/problems/longest-substring.html#edge-cases",
    "href": "dsa/problems/longest-substring.html#edge-cases",
    "title": "Longest Substring Without Repeating Characters",
    "section": "",
    "text": "Empty string\nSingle character\nAll characters are the same\nNo repeating characters\nUnicode characters",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Longest Substring Without Repeating Characters"
    ]
  },
  {
    "objectID": "dsa/problems/longest-substring.html#variations",
    "href": "dsa/problems/longest-substring.html#variations",
    "title": "Longest Substring Without Repeating Characters",
    "section": "",
    "text": "Longest Substring with At Most K Distinct Characters: Allow k different characters\nLongest Substring with At Most Two Distinct Characters: Special case of above\nMinimum Window Substring: Find shortest substring containing all characters from another string",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Longest Substring Without Repeating Characters"
    ]
  },
  {
    "objectID": "dsa/problems/two-sum.html",
    "href": "dsa/problems/two-sum.html",
    "title": "Two Sum",
    "section": "",
    "text": "Problem: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n\ndef two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\n# Example\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # [0, 1]\n\n\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n\n\n\nHash Map Approach: Use a hash map to store numbers we’ve seen\nOne Pass: For each number, check if its complement exists in the map\nReturn Indices: Return the indices when complement is found\n\n\n\n\n\nEmpty array\nNo solution exists\nDuplicate numbers\nArray with single element\n\n\n\n\n\nTwo Sum II (Sorted Array): Use two pointers approach\nThree Sum: Extend to find three numbers\nFour Sum: Extend to find four numbers",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Two Sum"
    ]
  },
  {
    "objectID": "dsa/problems/two-sum.html#solution",
    "href": "dsa/problems/two-sum.html#solution",
    "title": "Two Sum",
    "section": "",
    "text": "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\n# Example\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # [0, 1]",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Two Sum"
    ]
  },
  {
    "objectID": "dsa/problems/two-sum.html#analysis",
    "href": "dsa/problems/two-sum.html#analysis",
    "title": "Two Sum",
    "section": "",
    "text": "Time Complexity: O(n)\nSpace Complexity: O(n)",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Two Sum"
    ]
  },
  {
    "objectID": "dsa/problems/two-sum.html#approach",
    "href": "dsa/problems/two-sum.html#approach",
    "title": "Two Sum",
    "section": "",
    "text": "Hash Map Approach: Use a hash map to store numbers we’ve seen\nOne Pass: For each number, check if its complement exists in the map\nReturn Indices: Return the indices when complement is found",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Two Sum"
    ]
  },
  {
    "objectID": "dsa/problems/two-sum.html#edge-cases",
    "href": "dsa/problems/two-sum.html#edge-cases",
    "title": "Two Sum",
    "section": "",
    "text": "Empty array\nNo solution exists\nDuplicate numbers\nArray with single element",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Two Sum"
    ]
  },
  {
    "objectID": "dsa/problems/two-sum.html#variations",
    "href": "dsa/problems/two-sum.html#variations",
    "title": "Two Sum",
    "section": "",
    "text": "Two Sum II (Sorted Array): Use two pointers approach\nThree Sum: Extend to find three numbers\nFour Sum: Extend to find four numbers",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Two Sum"
    ]
  },
  {
    "objectID": "dsa/problems/valid-parentheses.html",
    "href": "dsa/problems/valid-parentheses.html",
    "title": "Valid Parentheses",
    "section": "",
    "text": "Problem: Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\n\ndef is_valid(s):\n    stack = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in '({[':\n            stack.append(char)\n        elif char in ')}]':\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    \n    return len(stack) == 0\n\n# Example\nprint(is_valid(\"()[]{}\"))  # True\nprint(is_valid(\"([)]\"))    # False\n\n\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n\n\n\nStack Approach: Use a stack to keep track of opening brackets\nMatching Pairs: For each closing bracket, check if it matches the top of stack\nValidation: Ensure stack is empty at the end\n\n\n\n\n\nEmpty string\nSingle character\nUnmatched opening brackets\nUnmatched closing brackets\nMixed bracket types\n\n\n\n\n\nGenerate Parentheses: Generate all valid combinations\nLongest Valid Parentheses: Find longest valid substring\nRemove Invalid Parentheses: Remove minimum characters to make valid",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Valid Parentheses"
    ]
  },
  {
    "objectID": "dsa/problems/valid-parentheses.html#solution",
    "href": "dsa/problems/valid-parentheses.html#solution",
    "title": "Valid Parentheses",
    "section": "",
    "text": "def is_valid(s):\n    stack = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in '({[':\n            stack.append(char)\n        elif char in ')}]':\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    \n    return len(stack) == 0\n\n# Example\nprint(is_valid(\"()[]{}\"))  # True\nprint(is_valid(\"([)]\"))    # False",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Valid Parentheses"
    ]
  },
  {
    "objectID": "dsa/problems/valid-parentheses.html#analysis",
    "href": "dsa/problems/valid-parentheses.html#analysis",
    "title": "Valid Parentheses",
    "section": "",
    "text": "Time Complexity: O(n)\nSpace Complexity: O(n)",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Valid Parentheses"
    ]
  },
  {
    "objectID": "dsa/problems/valid-parentheses.html#approach",
    "href": "dsa/problems/valid-parentheses.html#approach",
    "title": "Valid Parentheses",
    "section": "",
    "text": "Stack Approach: Use a stack to keep track of opening brackets\nMatching Pairs: For each closing bracket, check if it matches the top of stack\nValidation: Ensure stack is empty at the end",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Valid Parentheses"
    ]
  },
  {
    "objectID": "dsa/problems/valid-parentheses.html#edge-cases",
    "href": "dsa/problems/valid-parentheses.html#edge-cases",
    "title": "Valid Parentheses",
    "section": "",
    "text": "Empty string\nSingle character\nUnmatched opening brackets\nUnmatched closing brackets\nMixed bracket types",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Valid Parentheses"
    ]
  },
  {
    "objectID": "dsa/problems/valid-parentheses.html#variations",
    "href": "dsa/problems/valid-parentheses.html#variations",
    "title": "Valid Parentheses",
    "section": "",
    "text": "Generate Parentheses: Generate all valid combinations\nLongest Valid Parentheses: Find longest valid substring\nRemove Invalid Parentheses: Remove minimum characters to make valid",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Valid Parentheses"
    ]
  },
  {
    "objectID": "dsa/algorithms/kadane.html",
    "href": "dsa/algorithms/kadane.html",
    "title": "Kadane’s Algorithm",
    "section": "",
    "text": "Kadane’s Algorithm is a dynamic programming algorithm to find the maximum sum of a contiguous subarray in an array.\n\n\nKadane’s Algorithm is a dynamic programming algorithm to find the maximum sum of a contiguous subarray in an array.\nint kadane(int arr[], int n) {\n    int max_current = 0;\n    int max_global = 0;\n    for (int i = 0; i &lt; n; i++) {\n        max_current = max(arr[i], max_current + arr[i]);\n        max_global = max(max_global, max_current);\n    }\n    return max_global;\n}\n\n\n\n\nkadane is O(n) operation.\n\n\n\n\n\nkadane is O(1) operation.",
    "crumbs": [
      "Data Structures & Algorithms",
      "Algorithms",
      "Kadane's Algorithm"
    ]
  },
  {
    "objectID": "dsa/algorithms/kadane.html#explanation",
    "href": "dsa/algorithms/kadane.html#explanation",
    "title": "Kadane’s Algorithm",
    "section": "",
    "text": "Kadane’s Algorithm is a dynamic programming algorithm to find the maximum sum of a contiguous subarray in an array.\nint kadane(int arr[], int n) {\n    int max_current = 0;\n    int max_global = 0;\n    for (int i = 0; i &lt; n; i++) {\n        max_current = max(arr[i], max_current + arr[i]);\n        max_global = max(max_global, max_current);\n    }\n    return max_global;\n}",
    "crumbs": [
      "Data Structures & Algorithms",
      "Algorithms",
      "Kadane's Algorithm"
    ]
  },
  {
    "objectID": "dsa/algorithms/kadane.html#time-complexity",
    "href": "dsa/algorithms/kadane.html#time-complexity",
    "title": "Kadane’s Algorithm",
    "section": "",
    "text": "kadane is O(n) operation.",
    "crumbs": [
      "Data Structures & Algorithms",
      "Algorithms",
      "Kadane's Algorithm"
    ]
  },
  {
    "objectID": "dsa/algorithms/kadane.html#space-complexity",
    "href": "dsa/algorithms/kadane.html#space-complexity",
    "title": "Kadane’s Algorithm",
    "section": "",
    "text": "kadane is O(1) operation.",
    "crumbs": [
      "Data Structures & Algorithms",
      "Algorithms",
      "Kadane's Algorithm"
    ]
  },
  {
    "objectID": "dsa/data-structures/queue.html",
    "href": "dsa/data-structures/queue.html",
    "title": "Queue",
    "section": "",
    "text": "A queue is a linear data structure that follows the First In First Out (FIFO) principle.\n\n\n// Queue implementation in C++\n\n#include &lt;iostream&gt;\n#define SIZE 5\n\nusing namespace std;\n\nclass Queue {\n   private:\n  int items[SIZE], front, rear;\n\n   public:\n  Queue() {\n    front = -1;\n    rear = -1;\n  }\n\n  bool isFull() {\n    if (front == 0 && rear == SIZE - 1) {\n      return true;\n    }\n    return false;\n  }\n\n  bool isEmpty() {\n    if (front == -1)\n      return true;\n    else\n      return false;\n  }\n\n  void enQueue(int element) {\n    if (isFull()) {\n      cout &lt;&lt; \"Queue is full\";\n    } else {\n      if (front == -1) front = 0;\n      rear++;\n      items[rear] = element;\n      cout &lt;&lt; endl\n         &lt;&lt; \"Inserted \" &lt;&lt; element &lt;&lt; endl;\n    }\n  }\n\n  int deQueue() {\n    int element;\n    if (isEmpty()) {\n      cout &lt;&lt; \"Queue is empty\" &lt;&lt; endl;\n      return (-1);\n    } else {\n      element = items[front];\n      if (front &gt;= rear) {\n        front = -1;\n        rear = -1;\n      } /* Q has only one element, so we reset the queue after deleting it. */\n      else {\n        front++;\n      }\n      cout &lt;&lt; endl\n         &lt;&lt; \"Deleted -&gt; \" &lt;&lt; element &lt;&lt; endl;\n      return (element);\n    }\n  }\n\n  void display() {\n    /* Function to display elements of Queue */\n    int i;\n    if (isEmpty()) {\n      cout &lt;&lt; endl\n         &lt;&lt; \"Empty Queue\" &lt;&lt; endl;\n    } else {\n      cout &lt;&lt; endl\n         &lt;&lt; \"Front index-&gt; \" &lt;&lt; front;\n      cout &lt;&lt; endl\n         &lt;&lt; \"Items -&gt; \";\n      for (i = front; i &lt;= rear; i++)\n        cout &lt;&lt; items[i] &lt;&lt; \"  \";\n      cout &lt;&lt; endl\n         &lt;&lt; \"Rear index-&gt; \" &lt;&lt; rear &lt;&lt; endl;\n    }\n  }\n};\n\nint main() {\n  Queue q;\n\n  //deQueue is not possible on empty queue\n  q.deQueue();\n\n  //enQueue 5 elements\n  q.enQueue(1);\n  q.enQueue(2);\n  q.enQueue(3);\n  q.enQueue(4);\n  q.enQueue(5);\n\n  // 6th element can't be added to because the queue is full\n  q.enQueue(6);\n\n  q.display();\n\n  //deQueue removes element entered first i.e. 1\n  q.deQueue();\n\n  //Now we have just 4 elements\n  q.display();\n\n  return 0;\n}\n\n\n\n\nfront and rear are the indices of the front and rear elements of the queue.\nisFull checks if the queue is full.\nisEmpty checks if the queue is empty.\nenQueue adds an element to the queue.\ndeQueue removes an element from the queue.\ndisplay displays the elements of the queue.\n\n\n\n\n\nenQueue and deQueue are O(1) operations.\ndisplay is O(n) operation.",
    "crumbs": [
      "Data Structures & Algorithms",
      "Data Structures",
      "Queue"
    ]
  },
  {
    "objectID": "dsa/data-structures/queue.html#implementation",
    "href": "dsa/data-structures/queue.html#implementation",
    "title": "Queue",
    "section": "",
    "text": "// Queue implementation in C++\n\n#include &lt;iostream&gt;\n#define SIZE 5\n\nusing namespace std;\n\nclass Queue {\n   private:\n  int items[SIZE], front, rear;\n\n   public:\n  Queue() {\n    front = -1;\n    rear = -1;\n  }\n\n  bool isFull() {\n    if (front == 0 && rear == SIZE - 1) {\n      return true;\n    }\n    return false;\n  }\n\n  bool isEmpty() {\n    if (front == -1)\n      return true;\n    else\n      return false;\n  }\n\n  void enQueue(int element) {\n    if (isFull()) {\n      cout &lt;&lt; \"Queue is full\";\n    } else {\n      if (front == -1) front = 0;\n      rear++;\n      items[rear] = element;\n      cout &lt;&lt; endl\n         &lt;&lt; \"Inserted \" &lt;&lt; element &lt;&lt; endl;\n    }\n  }\n\n  int deQueue() {\n    int element;\n    if (isEmpty()) {\n      cout &lt;&lt; \"Queue is empty\" &lt;&lt; endl;\n      return (-1);\n    } else {\n      element = items[front];\n      if (front &gt;= rear) {\n        front = -1;\n        rear = -1;\n      } /* Q has only one element, so we reset the queue after deleting it. */\n      else {\n        front++;\n      }\n      cout &lt;&lt; endl\n         &lt;&lt; \"Deleted -&gt; \" &lt;&lt; element &lt;&lt; endl;\n      return (element);\n    }\n  }\n\n  void display() {\n    /* Function to display elements of Queue */\n    int i;\n    if (isEmpty()) {\n      cout &lt;&lt; endl\n         &lt;&lt; \"Empty Queue\" &lt;&lt; endl;\n    } else {\n      cout &lt;&lt; endl\n         &lt;&lt; \"Front index-&gt; \" &lt;&lt; front;\n      cout &lt;&lt; endl\n         &lt;&lt; \"Items -&gt; \";\n      for (i = front; i &lt;= rear; i++)\n        cout &lt;&lt; items[i] &lt;&lt; \"  \";\n      cout &lt;&lt; endl\n         &lt;&lt; \"Rear index-&gt; \" &lt;&lt; rear &lt;&lt; endl;\n    }\n  }\n};\n\nint main() {\n  Queue q;\n\n  //deQueue is not possible on empty queue\n  q.deQueue();\n\n  //enQueue 5 elements\n  q.enQueue(1);\n  q.enQueue(2);\n  q.enQueue(3);\n  q.enQueue(4);\n  q.enQueue(5);\n\n  // 6th element can't be added to because the queue is full\n  q.enQueue(6);\n\n  q.display();\n\n  //deQueue removes element entered first i.e. 1\n  q.deQueue();\n\n  //Now we have just 4 elements\n  q.display();\n\n  return 0;\n}",
    "crumbs": [
      "Data Structures & Algorithms",
      "Data Structures",
      "Queue"
    ]
  },
  {
    "objectID": "dsa/data-structures/queue.html#explanation",
    "href": "dsa/data-structures/queue.html#explanation",
    "title": "Queue",
    "section": "",
    "text": "front and rear are the indices of the front and rear elements of the queue.\nisFull checks if the queue is full.\nisEmpty checks if the queue is empty.\nenQueue adds an element to the queue.\ndeQueue removes an element from the queue.\ndisplay displays the elements of the queue.",
    "crumbs": [
      "Data Structures & Algorithms",
      "Data Structures",
      "Queue"
    ]
  },
  {
    "objectID": "dsa/data-structures/queue.html#time-complexity",
    "href": "dsa/data-structures/queue.html#time-complexity",
    "title": "Queue",
    "section": "",
    "text": "enQueue and deQueue are O(1) operations.\ndisplay is O(n) operation.",
    "crumbs": [
      "Data Structures & Algorithms",
      "Data Structures",
      "Queue"
    ]
  },
  {
    "objectID": "technical-blogs/001.html",
    "href": "technical-blogs/001.html",
    "title": "1.5+ million Pdfs in 25 mins",
    "section": "",
    "text": "Check the blog here",
    "crumbs": [
      "Technical Blogs",
      "1.5+ million Pdfs in 25 mins"
    ]
  },
  {
    "objectID": "technical-blogs/001.html#overview",
    "href": "technical-blogs/001.html#overview",
    "title": "1.5+ million Pdfs in 25 mins",
    "section": "Overview",
    "text": "Overview\nThis analysis discusses Zerodha’s overhaul of their PDF contract note generation and delivery system, which transformed a legacy workflow from an 8-hour batch process into a horizontally scalable, event-driven architecture that produces and sends 1.5+ million digital contract notes within 25 minutes. The process leverages cloud-native design principles, distributed job orchestration, and high-throughput storage solutions to meet regulatory deadlines and volatile, scale-driven demand[1].",
    "crumbs": [
      "Technical Blogs",
      "1.5+ million Pdfs in 25 mins"
    ]
  },
  {
    "objectID": "technical-blogs/001.html#legacy-system-challenges",
    "href": "technical-blogs/001.html#legacy-system-challenges",
    "title": "1.5+ million Pdfs in 25 mins",
    "section": "Legacy System Challenges",
    "text": "Legacy System Challenges\n\nMonolithic, Vertically Scaled Architecture: The original design was a large, single-server setup that sequentially processed each step, resulting in 7-8 hour runtimes.\nProcess Pipeline:\n\nPython-generated HTML contract notes from CSV EOD dumps.\nHTML-to-PDF via Chrome (Puppeteer).\nPDF digital signature with a Java CLI.\nEmail delivery via a self-hosted SMTP server.\n\nBottlenecks:\n\nLong execution times (risking regulatory non-compliance).\nSMTP server throughput limitations.\nScalability ceiling due to single-machine design.\nResource waste on spikes due to vertically scaling for peak demand.",
    "crumbs": [
      "Technical Blogs",
      "1.5+ million Pdfs in 25 mins"
    ]
  },
  {
    "objectID": "technical-blogs/001.html#new-system-architecture",
    "href": "technical-blogs/001.html#new-system-architecture",
    "title": "1.5+ million Pdfs in 25 mins",
    "section": "New System Architecture",
    "text": "New System Architecture\n\nDesign Principles\n\nHorizontal Scalability: Processes are distributed across ephemeral EC2 instances, saturating all available cores for short-lived, high-throughput processing.\nJob Chaining/Orchestration: The system decomposes the workflow into independent jobs handled by specialized workers, managed by a custom Go-based messaging library (Tasqueue).\nCloud-Native Choices: Leverages stateless compute, object storage (S3), and a job state backend (Redis).\n\n\n\nWorkflow Overview\n\nData Processing Worker: Parses exchange data and prepares template-ready input.\nPDF Generation Worker: Converts templates to PDFs.\nPDF Signing Worker: Digitally signs, encrypts PDFs.\nEmail Worker: Delivers signed PDFs to users[1].\n\nEach stage writes outputs to S3, which serves as the shared scratch space for the next.\n\nDistributed Job Chaining Example\n\nEach contract note passes through four jobs: data processing → PDF generation → PDF signing → email, with outputs (e.g., PDFs) exchanged via S3.",
    "crumbs": [
      "Technical Blogs",
      "1.5+ million Pdfs in 25 mins"
    ]
  },
  {
    "objectID": "technical-blogs/001.html#core-components-and-technical-decisions",
    "href": "technical-blogs/001.html#core-components-and-technical-decisions",
    "title": "1.5+ million Pdfs in 25 mins",
    "section": "Core Components and Technical Decisions",
    "text": "Core Components and Technical Decisions\n\n1. Worker Implementation\n\nLanguage Shift: Workers were rewritten from Python to Go, yielding significant speed and efficiency gains.\nTask Distribution: Custom “Tasqueue” job library coordinates which worker does what. Redis tracks job states and triggers targeted retries for failed jobs.\n\n\n\n2. PDF Generation Pipeline\n\n\n\n\n\n\n\n\nGeneration Mode\nPerformance Impact\nProblems\n\n\n\n\nHTML (Puppeteer)\nBaseline, but slow and resource-intensive\nHigh resource usage, slow for scale\n\n\nLaTeX (pdflatex)\n10x faster than Puppeteer\nStatic memory limits (fails for large files)\n\n\nLaTeX (lualatex)\nDynamic memory allocation, handles large PDFs\nOccasional failures, difficult stack traces, large Docker images\n\n\nTypst\n2–3x faster for small; 18x for massive PDFs\nNone significant; much leaner Docker images\n\n\n\n\nModernization: The switch to Typst, a Rust-based typesetting system, resulted in substantial performance boosts (e.g., 2,000-page PDF in Typst = 1 minute vs. 18 minutes in lualatex), with smaller Docker images and simpler debugging.\n\n\n\n3. Digital PDF Signing\n\nJava OpenPDF: No open-source tool existed to batch sign PDFs efficiently. Zerodha built a lightweight HTTP wrapper over Java’s OpenPDF library, allowing concurrent signing in a JVM running as a sidecar for each worker container.\n\n\n\n4. Storage and File Exchange\n\n\n\n\n\n\n\n\nStorage Option\nRead/Write Perf. (10,000 files)\nBottlenecks / Suitability\n\n\n\n\nEFS (GP mode)\n4–5 seconds\nHit operations per second limits, unsuitable\n\n\nEFS (Max I/O)\n17–18 seconds\nHigh latency, worse than GP, unsuitable\n\n\nEBS\n400 ms\nFast but used only for local ephemeral storage\n\n\nS3\n4–5 seconds\nChosen for low cost, acceptable burst, easy ops\n\n\n\n\nS3 Chosen: After tests, S3 was selected for its cost and manageability, despite needing to engineer around its per-prefix rate limits (3,500 write/5,500 read requests per second per prefix).\nKey Management: Initially used KSUIDs with natural prefix collisions (“hot prefixes”); refactored to maximize key space diversity and avoid rate limiting.\n\n\n\n5. Scaling and Throughput\n\nEphemeral Computing: Instantiates large EC2 fleets dynamically, saturates CPUs, spins down instantly post-batch.\nFile and Worker Pooling: Maximizes concurrency, efficiently balances variable job sizes (e.g., users with 2- vs. 2,000-page reports).\n\n\n\n6. Monitoring and Reliability\n\nRedis State Store: Tracks job progress, identifies and triggers retries for failed jobs.\nGraceful Failure Handling: Intelligent retry policies, due to fail-fast, distributed design.",
    "crumbs": [
      "Technical Blogs",
      "1.5+ million Pdfs in 25 mins"
    ]
  },
  {
    "objectID": "technical-blogs/001.html#key-system-design-insights",
    "href": "technical-blogs/001.html#key-system-design-insights",
    "title": "1.5+ million Pdfs in 25 mins",
    "section": "Key System Design Insights",
    "text": "Key System Design Insights\n\nDistributed Batching works best under bursty, high-throughput workloads—design so each worker can independently process units of work with minimal coordination.\nToolchain Choices matter: Moving from interpreted (Python) to compiled languages (Go), and from heavyweight containers (Chrome, LaTeX) to single binaries (Typst) enable massive reductions in resource usage.\nShared Object Storage (S3) proves practical for high-concurrency workloads if request prefix sharding is handled carefully.\nCustom Lightweight Libraries can outperform generic job brokers when tuned for specific dataflows, especially at extreme scale.",
    "crumbs": [
      "Technical Blogs",
      "1.5+ million Pdfs in 25 mins"
    ]
  },
  {
    "objectID": "technical-blogs/001.html#quantitative-outcomes",
    "href": "technical-blogs/001.html#quantitative-outcomes",
    "title": "1.5+ million Pdfs in 25 mins",
    "section": "Quantitative Outcomes",
    "text": "Quantitative Outcomes\n\nEnd-to-End Performance: 1.5+ million PDFs generated, signed, and emailed in ~25 minutes.\nResource Efficiency: Negligible incremental costs due to ephemeral compute and optimal containerization.\nReliability: Sub-1% error rates for bursty, high-concurrency jobs, with good retry logic.",
    "crumbs": [
      "Technical Blogs",
      "1.5+ million Pdfs in 25 mins"
    ]
  },
  {
    "objectID": "technical-blogs/001.html#lessons-and-trade-offs",
    "href": "technical-blogs/001.html#lessons-and-trade-offs",
    "title": "1.5+ million Pdfs in 25 mins",
    "section": "Lessons and Trade-offs",
    "text": "Lessons and Trade-offs\n\nPros:\n\nOrder-of-magnitude speedup.\nSignificant cloud cost reduction.\nSystem adaptivity to daily volume fluctuations.\nSimple, maintainable worker design.\n\nCons/Risks:\n\nReliance on S3 limits—requires ongoing bucket prefix diversity management.\nDigital signing still bottlenecked by FOSS library limitations.\nContinuous need for observability and error monitoring.",
    "crumbs": [
      "Technical Blogs",
      "1.5+ million Pdfs in 25 mins"
    ]
  },
  {
    "objectID": "technical-blogs/001.html#conclusion",
    "href": "technical-blogs/001.html#conclusion",
    "title": "1.5+ million Pdfs in 25 mins",
    "section": "Conclusion",
    "text": "Conclusion\nThe re-architecture demonstrates a highly effective adoption of distributed systems patterns for time-sensitive, large-scale workload automation in the financial sector. Key innovations include aggressively parallelized worker pools, cloud-native storage strategies, and constant toolchain optimization for both speed and maintainability. Zerodha’s experience offers a model for similar large-scale, compliance-driven batch processing systems[1].",
    "crumbs": [
      "Technical Blogs",
      "1.5+ million Pdfs in 25 mins"
    ]
  },
  {
    "objectID": "technical-blogs/index.html",
    "href": "technical-blogs/index.html",
    "title": "Technical Blogs",
    "section": "",
    "text": "Welcome to my Technical Blog Breakdown section! Here I analyze and break down interesting technical articles, engineering blogs, and industry insights to extract key learnings and practical knowledge.\n\n\n\n1.5+ million Pdfs in 25 mins",
    "crumbs": [
      "Technical Blogs"
    ]
  },
  {
    "objectID": "technical-blogs/index.html#quick-navigation",
    "href": "technical-blogs/index.html#quick-navigation",
    "title": "Technical Blogs",
    "section": "",
    "text": "1.5+ million Pdfs in 25 mins",
    "crumbs": [
      "Technical Blogs"
    ]
  },
  {
    "objectID": "dsa/data-structures/index.html",
    "href": "dsa/data-structures/index.html",
    "title": "Data Structures",
    "section": "",
    "text": "This section covers the fundamental data structures used in algorithms and programming.\n\n\n\nArrays\nLinked Lists\nStacks\nQueues\nHeaps\nTrees\nGraphs\nHash Tables",
    "crumbs": [
      "Data Structures & Algorithms",
      "Data Structures"
    ]
  },
  {
    "objectID": "dsa/data-structures/index.html#quick-navigation",
    "href": "dsa/data-structures/index.html#quick-navigation",
    "title": "Data Structures",
    "section": "",
    "text": "Arrays\nLinked Lists\nStacks\nQueues\nHeaps\nTrees\nGraphs\nHash Tables",
    "crumbs": [
      "Data Structures & Algorithms",
      "Data Structures"
    ]
  },
  {
    "objectID": "dsa/algorithms/index.html",
    "href": "dsa/algorithms/index.html",
    "title": "Algorithms",
    "section": "",
    "text": "This section covers the fundamental algorithms used in algorithms and programming.\n\n\n\nKadane’s Algorithm",
    "crumbs": [
      "Data Structures & Algorithms",
      "Algorithms"
    ]
  },
  {
    "objectID": "dsa/algorithms/index.html#quick-navigation",
    "href": "dsa/algorithms/index.html#quick-navigation",
    "title": "Algorithms",
    "section": "",
    "text": "Kadane’s Algorithm",
    "crumbs": [
      "Data Structures & Algorithms",
      "Algorithms"
    ]
  },
  {
    "objectID": "dsa/problems/index.html",
    "href": "dsa/problems/index.html",
    "title": "Practice Problems",
    "section": "",
    "text": "A collection of DSA problems with solutions and explanations.\n\n\n\nNeetcode 150 \nSome Leetcode Lists :\n\nGraphs List\nRecursion List\nTrees List\nDynamic Programming List\n\nClassic DP\nLinear DP\nKnapsack DP\nDP on Grids\nDP on Digits\nDP on Maths\nDP on Strings\nDP on Trees & Graphs\nDP on Bit Manipulation\n\nBinary Search List\nHeaps, Array, String List\n\n\n\n\n\n\n\n\n\n\n\nBefore Starting\n\n\n\n\nUnderstand the problem: Read carefully, identify inputs/outputs\nConsider examples: Work through small examples manually\nIdentify patterns: Look for common algorithmic patterns\nPlan your approach: Choose appropriate data structures\nConsider edge cases: Empty inputs, single elements, etc.\n\n\n\n\n\n\n\n\n\nCommon Mistakes\n\n\n\n\nNot handling edge cases\nIncorrect time/space complexity analysis\nNot optimizing for the specific constraints\nOvercomplicating simple problems\n\n\n\n\n\n\n\n\n\nLeetCode: 2000+ problems with varying difficulty\nHackerRank: Good for beginners, company-specific problems\nCodeforces: Competitive programming, regular contests\nAtCoder: Japanese platform, good for learning\n\n\n\n\n\nArrays & Strings: Two pointers, sliding window, prefix sums\nLinked Lists: Fast/slow pointers, reversing, merging\nTrees: DFS/BFS, recursion, tree construction\nGraphs: DFS/BFS, shortest paths, topological sort\nDynamic Programming: Memoization, tabulation, state transitions\nBinary Search: Finding boundaries, optimization problems",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems"
    ]
  },
  {
    "objectID": "dsa/problems/index.html#we-will-be-following-on-some-list-of-problems-from",
    "href": "dsa/problems/index.html#we-will-be-following-on-some-list-of-problems-from",
    "title": "Practice Problems",
    "section": "",
    "text": "Neetcode 150 \nSome Leetcode Lists :\n\nGraphs List\nRecursion List\nTrees List\nDynamic Programming List\n\nClassic DP\nLinear DP\nKnapsack DP\nDP on Grids\nDP on Digits\nDP on Maths\nDP on Strings\nDP on Trees & Graphs\nDP on Bit Manipulation\n\nBinary Search List\nHeaps, Array, String List",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems"
    ]
  },
  {
    "objectID": "dsa/problems/index.html#problem-solving-tips",
    "href": "dsa/problems/index.html#problem-solving-tips",
    "title": "Practice Problems",
    "section": "",
    "text": "Before Starting\n\n\n\n\nUnderstand the problem: Read carefully, identify inputs/outputs\nConsider examples: Work through small examples manually\nIdentify patterns: Look for common algorithmic patterns\nPlan your approach: Choose appropriate data structures\nConsider edge cases: Empty inputs, single elements, etc.\n\n\n\n\n\n\n\n\n\nCommon Mistakes\n\n\n\n\nNot handling edge cases\nIncorrect time/space complexity analysis\nNot optimizing for the specific constraints\nOvercomplicating simple problems",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems"
    ]
  },
  {
    "objectID": "dsa/problems/index.html#practice-resources",
    "href": "dsa/problems/index.html#practice-resources",
    "title": "Practice Problems",
    "section": "",
    "text": "LeetCode: 2000+ problems with varying difficulty\nHackerRank: Good for beginners, company-specific problems\nCodeforces: Competitive programming, regular contests\nAtCoder: Japanese platform, good for learning\n\n\n\n\n\nArrays & Strings: Two pointers, sliding window, prefix sums\nLinked Lists: Fast/slow pointers, reversing, merging\nTrees: DFS/BFS, recursion, tree construction\nGraphs: DFS/BFS, shortest paths, topological sort\nDynamic Programming: Memoization, tabulation, state transitions\nBinary Search: Finding boundaries, optimization problems",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems"
    ]
  },
  {
    "objectID": "dsa/problems/climbing-stairs.html",
    "href": "dsa/problems/climbing-stairs.html",
    "title": "Climbing Stairs",
    "section": "",
    "text": "Problem: You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n\ndef climb_stairs(n):\n    if n &lt;= 2:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\n# Space optimized version\ndef climb_stairs_optimized(n):\n    if n &lt;= 2:\n        return n\n    \n    prev, curr = 1, 2\n    for i in range(3, n + 1):\n        prev, curr = curr, prev + curr\n    \n    return curr\n\n\n\nTime Complexity: O(n)\nSpace Complexity: O(1) for optimized version\n\n\n\n\nDynamic Programming: Use DP to build solution from smaller subproblems\nFibonacci Pattern: Number of ways follows Fibonacci sequence\nSpace Optimization: Only need to keep track of previous two values\n\n\n\n\n\nn = 0 (no steps)\nn = 1 (one step)\nn = 2 (two steps)\nLarge values of n\n\n\n\n\n\nMin Cost Climbing Stairs: Each step has a cost\nClimbing Stairs with Constraints: Can’t climb certain steps\nDifferent Step Sizes: Can climb 1, 2, or 3 steps at a time",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Climbing Stairs"
    ]
  },
  {
    "objectID": "dsa/problems/climbing-stairs.html#solution",
    "href": "dsa/problems/climbing-stairs.html#solution",
    "title": "Climbing Stairs",
    "section": "",
    "text": "def climb_stairs(n):\n    if n &lt;= 2:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\n# Space optimized version\ndef climb_stairs_optimized(n):\n    if n &lt;= 2:\n        return n\n    \n    prev, curr = 1, 2\n    for i in range(3, n + 1):\n        prev, curr = curr, prev + curr\n    \n    return curr",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Climbing Stairs"
    ]
  },
  {
    "objectID": "dsa/problems/climbing-stairs.html#analysis",
    "href": "dsa/problems/climbing-stairs.html#analysis",
    "title": "Climbing Stairs",
    "section": "",
    "text": "Time Complexity: O(n)\nSpace Complexity: O(1) for optimized version",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Climbing Stairs"
    ]
  },
  {
    "objectID": "dsa/problems/climbing-stairs.html#approach",
    "href": "dsa/problems/climbing-stairs.html#approach",
    "title": "Climbing Stairs",
    "section": "",
    "text": "Dynamic Programming: Use DP to build solution from smaller subproblems\nFibonacci Pattern: Number of ways follows Fibonacci sequence\nSpace Optimization: Only need to keep track of previous two values",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Climbing Stairs"
    ]
  },
  {
    "objectID": "dsa/problems/climbing-stairs.html#edge-cases",
    "href": "dsa/problems/climbing-stairs.html#edge-cases",
    "title": "Climbing Stairs",
    "section": "",
    "text": "n = 0 (no steps)\nn = 1 (one step)\nn = 2 (two steps)\nLarge values of n",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Climbing Stairs"
    ]
  },
  {
    "objectID": "dsa/problems/climbing-stairs.html#variations",
    "href": "dsa/problems/climbing-stairs.html#variations",
    "title": "Climbing Stairs",
    "section": "",
    "text": "Min Cost Climbing Stairs: Each step has a cost\nClimbing Stairs with Constraints: Can’t climb certain steps\nDifferent Step Sizes: Can climb 1, 2, or 3 steps at a time",
    "crumbs": [
      "Data Structures & Algorithms",
      "Practice Problems",
      "Climbing Stairs"
    ]
  },
  {
    "objectID": "dsa/index.html",
    "href": "dsa/index.html",
    "title": "Data Structures & Algorithms",
    "section": "",
    "text": "Welcome to my DSA learning journey! This section covers fundamental computer science concepts, problem-solving techniques, and algorithmic thinking.\n\n\n\nData Structures - Arrays, Linked Lists, Trees, Graphs, Hash Tables, etc.\nAlgorithms - Sorting, Searching, Dynamic Programming, Greedy, etc.\nProblems - Practice problems and solutions",
    "crumbs": [
      "Data Structures & Algorithms"
    ]
  },
  {
    "objectID": "dsa/index.html#quick-navigation",
    "href": "dsa/index.html#quick-navigation",
    "title": "Data Structures & Algorithms",
    "section": "",
    "text": "Data Structures - Arrays, Linked Lists, Trees, Graphs, Hash Tables, etc.\nAlgorithms - Sorting, Searching, Dynamic Programming, Greedy, etc.\nProblems - Practice problems and solutions",
    "crumbs": [
      "Data Structures & Algorithms"
    ]
  },
  {
    "objectID": "books/reading-list/designing-data-intensive.html",
    "href": "books/reading-list/designing-data-intensive.html",
    "title": "Designing Data-Intensive Applications",
    "section": "",
    "text": "Author: Martin Kleppmann\nPublished: 2017\nPages: 616\nRating: ⭐⭐⭐⭐⭐\n\n\nA comprehensive guide to designing large-scale data systems, covering the principles behind reliable, scalable, and maintainable applications.\n\n\n\n\n\n\nReliability: Fault tolerance and fault prevention\nScalability: Performance under load\nMaintainability: Operability, simplicity, and evolvability\n\n\n\n\n\nReplication: Leader-follower, multi-leader, leaderless\nPartitioning: Horizontal and vertical partitioning\nTransactions: ACID properties and isolation levels\n\n\n\n\n\nBatch Processing: MapReduce and data warehouses\nStream Processing: Event streams and stream processing\nFuture of Data Systems: Unifying batch and stream processing\n\n\n\n\n\n\n\n\nData is more important than code\nData outlives applications\nData is the source of truth\n\n\n\n\n\nConsistency vs. Availability: CAP theorem\nLatency vs. Throughput: Performance trade-offs\nSimplicity vs. Functionality: Complexity management\n\n\n\n\n\nFrom monolithic to microservices\nFrom batch to real-time processing\nFrom relational to polyglot persistence\n\n\n\n\n\n\n\n\nRelational: ACID transactions, complex queries\nDocument: Schema flexibility, hierarchical data\nGraph: Complex relationships, graph algorithms\nKey-Value: Simple queries, high performance\n\n\n\n\n\nSynchronous: Strong consistency, higher latency\nAsynchronous: Better performance, eventual consistency\nSemi-synchronous: Balance between consistency and performance\n\n\n\n\n\nHash-based: Even distribution, no range queries\nRange-based: Range queries, potential hotspots\nComposite: Best of both worlds, more complex\n\n\n\n\n\n\n\nclass EventStore:\n    def __init__(self):\n        self.events = []\n    \n    def append_event(self, event):\n        self.events.append(event)\n    \n    def get_events(self, aggregate_id):\n        return [e for e in self.events if e.aggregate_id == aggregate_id]\n    \n    def get_aggregate(self, aggregate_id):\n        events = self.get_events(aggregate_id)\n        aggregate = Aggregate()\n        for event in events:\n            aggregate.apply(event)\n        return aggregate\n\nclass Order:\n    def __init__(self):\n        self.id = None\n        self.items = []\n        self.status = \"created\"\n    \n    def apply(self, event):\n        if isinstance(event, OrderCreated):\n            self.id = event.order_id\n        elif isinstance(event, ItemAdded):\n            self.items.append(event.item)\n        elif isinstance(event, OrderConfirmed):\n            self.status = \"confirmed\"\n\n\n\nclass CommandHandler:\n    def handle_create_order(self, command):\n        # Write side - update write model\n        order = Order(command.order_id, command.items)\n        self.order_repository.save(order)\n        \n        # Publish event\n        event = OrderCreated(command.order_id, command.items)\n        self.event_bus.publish(event)\n\nclass QueryHandler:\n    def get_order_summary(self, order_id):\n        # Read side - query read model\n        return self.order_summary_repository.find_by_id(order_id)\n    \n    def handle_order_created(self, event):\n        # Update read model\n        summary = OrderSummary(\n            event.order_id,\n            len(event.items),\n            sum(item.price for item in event.items)\n        )\n        self.order_summary_repository.save(summary)\n\n\n\n\n\n\n\nComprehensive Coverage: Covers all aspects of data-intensive systems\nPractical Examples: Real-world case studies and code examples\nBalanced Perspective: Discusses trade-offs without being dogmatic\nFuture-Oriented: Covers emerging trends and technologies\n\n\n\n\n\nComplexity: Can be overwhelming for beginners\nRapid Evolution: Some technologies mentioned may be outdated\nDepth vs. Breadth: Some topics could use more detailed coverage\n\n\n\n\n\n\nDatabase Internals by Alex Petrov\nBuilding Microservices by Sam Newman\nDomain-Driven Design by Eric Evans\nSite Reliability Engineering by Google\n\n\n\n\n\n\n\nReliability: System continues to work correctly even when things go wrong\nScalability: System’s ability to cope with increased load\nMaintainability: System’s ability to be modified and maintained\n\n\n\n\n\nRelational Model: Tables, rows, columns, relationships\nDocument Model: Self-contained documents, schema flexibility\nGraph Model: Vertices, edges, complex relationships\n\n\n\n\n\nLog-structured Storage: Append-only logs for write performance\nB-tree Storage: Balanced trees for read performance\nColumn-oriented Storage: Optimized for analytical queries",
    "crumbs": [
      "Books",
      "Reading List",
      "Designing Data-Intensive Applications"
    ]
  },
  {
    "objectID": "books/reading-list/designing-data-intensive.html#overview",
    "href": "books/reading-list/designing-data-intensive.html#overview",
    "title": "Designing Data-Intensive Applications",
    "section": "",
    "text": "A comprehensive guide to designing large-scale data systems, covering the principles behind reliable, scalable, and maintainable applications.",
    "crumbs": [
      "Books",
      "Reading List",
      "Designing Data-Intensive Applications"
    ]
  },
  {
    "objectID": "books/reading-list/designing-data-intensive.html#key-topics-covered",
    "href": "books/reading-list/designing-data-intensive.html#key-topics-covered",
    "title": "Designing Data-Intensive Applications",
    "section": "",
    "text": "Reliability: Fault tolerance and fault prevention\nScalability: Performance under load\nMaintainability: Operability, simplicity, and evolvability\n\n\n\n\n\nReplication: Leader-follower, multi-leader, leaderless\nPartitioning: Horizontal and vertical partitioning\nTransactions: ACID properties and isolation levels\n\n\n\n\n\nBatch Processing: MapReduce and data warehouses\nStream Processing: Event streams and stream processing\nFuture of Data Systems: Unifying batch and stream processing",
    "crumbs": [
      "Books",
      "Reading List",
      "Designing Data-Intensive Applications"
    ]
  },
  {
    "objectID": "books/reading-list/designing-data-intensive.html#key-insights",
    "href": "books/reading-list/designing-data-intensive.html#key-insights",
    "title": "Designing Data-Intensive Applications",
    "section": "",
    "text": "Data is more important than code\nData outlives applications\nData is the source of truth\n\n\n\n\n\nConsistency vs. Availability: CAP theorem\nLatency vs. Throughput: Performance trade-offs\nSimplicity vs. Functionality: Complexity management\n\n\n\n\n\nFrom monolithic to microservices\nFrom batch to real-time processing\nFrom relational to polyglot persistence",
    "crumbs": [
      "Books",
      "Reading List",
      "Designing Data-Intensive Applications"
    ]
  },
  {
    "objectID": "books/reading-list/designing-data-intensive.html#practical-applications",
    "href": "books/reading-list/designing-data-intensive.html#practical-applications",
    "title": "Designing Data-Intensive Applications",
    "section": "",
    "text": "Relational: ACID transactions, complex queries\nDocument: Schema flexibility, hierarchical data\nGraph: Complex relationships, graph algorithms\nKey-Value: Simple queries, high performance\n\n\n\n\n\nSynchronous: Strong consistency, higher latency\nAsynchronous: Better performance, eventual consistency\nSemi-synchronous: Balance between consistency and performance\n\n\n\n\n\nHash-based: Even distribution, no range queries\nRange-based: Range queries, potential hotspots\nComposite: Best of both worlds, more complex",
    "crumbs": [
      "Books",
      "Reading List",
      "Designing Data-Intensive Applications"
    ]
  },
  {
    "objectID": "books/reading-list/designing-data-intensive.html#code-examples",
    "href": "books/reading-list/designing-data-intensive.html#code-examples",
    "title": "Designing Data-Intensive Applications",
    "section": "",
    "text": "class EventStore:\n    def __init__(self):\n        self.events = []\n    \n    def append_event(self, event):\n        self.events.append(event)\n    \n    def get_events(self, aggregate_id):\n        return [e for e in self.events if e.aggregate_id == aggregate_id]\n    \n    def get_aggregate(self, aggregate_id):\n        events = self.get_events(aggregate_id)\n        aggregate = Aggregate()\n        for event in events:\n            aggregate.apply(event)\n        return aggregate\n\nclass Order:\n    def __init__(self):\n        self.id = None\n        self.items = []\n        self.status = \"created\"\n    \n    def apply(self, event):\n        if isinstance(event, OrderCreated):\n            self.id = event.order_id\n        elif isinstance(event, ItemAdded):\n            self.items.append(event.item)\n        elif isinstance(event, OrderConfirmed):\n            self.status = \"confirmed\"\n\n\n\nclass CommandHandler:\n    def handle_create_order(self, command):\n        # Write side - update write model\n        order = Order(command.order_id, command.items)\n        self.order_repository.save(order)\n        \n        # Publish event\n        event = OrderCreated(command.order_id, command.items)\n        self.event_bus.publish(event)\n\nclass QueryHandler:\n    def get_order_summary(self, order_id):\n        # Read side - query read model\n        return self.order_summary_repository.find_by_id(order_id)\n    \n    def handle_order_created(self, event):\n        # Update read model\n        summary = OrderSummary(\n            event.order_id,\n            len(event.items),\n            sum(item.price for item in event.items)\n        )\n        self.order_summary_repository.save(summary)",
    "crumbs": [
      "Books",
      "Reading List",
      "Designing Data-Intensive Applications"
    ]
  },
  {
    "objectID": "books/reading-list/designing-data-intensive.html#critical-analysis",
    "href": "books/reading-list/designing-data-intensive.html#critical-analysis",
    "title": "Designing Data-Intensive Applications",
    "section": "",
    "text": "Comprehensive Coverage: Covers all aspects of data-intensive systems\nPractical Examples: Real-world case studies and code examples\nBalanced Perspective: Discusses trade-offs without being dogmatic\nFuture-Oriented: Covers emerging trends and technologies\n\n\n\n\n\nComplexity: Can be overwhelming for beginners\nRapid Evolution: Some technologies mentioned may be outdated\nDepth vs. Breadth: Some topics could use more detailed coverage",
    "crumbs": [
      "Books",
      "Reading List",
      "Designing Data-Intensive Applications"
    ]
  },
  {
    "objectID": "books/reading-list/designing-data-intensive.html#related-books",
    "href": "books/reading-list/designing-data-intensive.html#related-books",
    "title": "Designing Data-Intensive Applications",
    "section": "",
    "text": "Database Internals by Alex Petrov\nBuilding Microservices by Sam Newman\nDomain-Driven Design by Eric Evans\nSite Reliability Engineering by Google",
    "crumbs": [
      "Books",
      "Reading List",
      "Designing Data-Intensive Applications"
    ]
  },
  {
    "objectID": "books/reading-list/designing-data-intensive.html#reading-notes",
    "href": "books/reading-list/designing-data-intensive.html#reading-notes",
    "title": "Designing Data-Intensive Applications",
    "section": "",
    "text": "Reliability: System continues to work correctly even when things go wrong\nScalability: System’s ability to cope with increased load\nMaintainability: System’s ability to be modified and maintained\n\n\n\n\n\nRelational Model: Tables, rows, columns, relationships\nDocument Model: Self-contained documents, schema flexibility\nGraph Model: Vertices, edges, complex relationships\n\n\n\n\n\nLog-structured Storage: Append-only logs for write performance\nB-tree Storage: Balanced trees for read performance\nColumn-oriented Storage: Optimized for analytical queries",
    "crumbs": [
      "Books",
      "Reading List",
      "Designing Data-Intensive Applications"
    ]
  },
  {
    "objectID": "books/index.html",
    "href": "books/index.html",
    "title": "Books",
    "section": "",
    "text": "Welcome to my Books section! Here I document my reading journey through technical books, share detailed notes, and track my learning progress across various software development topics.\n\n\n\nReading List - Current and planned books\nNotes - Detailed book notes and summaries\n\n\n\n\n\n\n\nCore Fundamentals: Algorithm design, complexity analysis\nProblem Solving: Interview preparation, competitive programming\nAdvanced Topics: Dynamic programming, graph algorithms\n\n\n\n\n\nDistributed Systems: Scalability, consistency, fault tolerance\nSoftware Architecture: Design patterns, best practices\nCloud-Native: Microservices, containers, serverless\n\n\n\n\n\nLanguage Deep Dives: Python, JavaScript, Go, Rust\nProgramming Paradigms: Functional, object-oriented, concurrent\nCode Quality: Clean code, refactoring, testing\n\n\n\n\n\nContainerization: Docker, Kubernetes, orchestration\nCloud Platforms: AWS, GCP, Azure services and patterns\nMonitoring & Observability: Logging, metrics, tracing\n\n\n\n\n\nApplication Security: OWASP, secure coding practices\nInfrastructure Security: Network security, access control\nCompliance: GDPR, SOC2, security frameworks\n\n\n\n\n\nDatabase Design: SQL, NoSQL, data modeling\nData Engineering: ETL, data pipelines, analytics\nMachine Learning: Algorithms, frameworks, MLOps\n\n\n\n\n\n\n\n\nCurrent Needs: Books relevant to my current projects\nSkill Gaps: Areas where I need improvement\nIndustry Trends: Emerging technologies and practices\nClassics: Timeless books that every developer should read\n\n\n\n\n\nActive Reading: Take notes, highlight key concepts\nImplementation: Build examples and practice exercises\nReflection: Connect concepts to real-world applications\nSharing: Write summaries and share insights\n\n\n\n\n## Book: [Title]\n**Author**: [Author Name]  \n**Category**: [DSA/System Design/Programming/etc.]  \n**Status**: [Reading/Completed/Planned]  \n**Rating**: [1-5 stars]\n\n### Summary\n[2-3 sentence overview of the book]\n\n### Key Concepts\n- [Concept 1 with explanation]\n- [Concept 2 with explanation]\n- [Concept 3 with explanation]\n\n### Code Examples\n[Important code snippets and implementations]\n\n### Practical Applications\n[How to apply concepts in real projects]\n\n### Questions & Follow-up\n[Topics to explore further]\n\n\n\n\n\n\n\n\nProgress: 60%\nCategory: System Design\nKey Learnings: Data models, storage engines, distributed systems\nRecent Notes: - Chapter 3: Storage and Retrieval - B-tree vs LSM-tree trade-offs - Chapter 4: Encoding and Evolution - Schema evolution strategies - Chapter 5: Replication - Leader-follower, consensus algorithms\n\n\n\nProgress: 40%\nCategory: DSA\nKey Learnings: Problem-solving techniques, interview strategies\nRecent Notes: - Arrays & Strings: Two pointers, sliding window techniques - Linked Lists: Fast/slow pointers, reversing, merging - Trees & Graphs: DFS/BFS, tree construction patterns\n\n\n\n\n\n\nRating: ⭐⭐⭐⭐⭐\nCategory: Programming\nKey Takeaways: Meaningful names, small functions, SOLID principles\nImpact: Improved code organization and maintainability in current projects.\n\n\n\nRating: ⭐⭐⭐⭐⭐\nCategory: Programming\nKey Takeaways: DRY principle, automation, continuous learning\nImpact: Enhanced development workflow and tool usage.\n\n\n\n\n\n\n\n“System Design Interview” by Alex Xu - Interview preparation\n“Building Microservices” by Sam Newman - Architecture patterns\n“Kubernetes in Action” by Marko Lukša - Container orchestration\n\n\n\n\n\n“Effective Python” by Brett Slatkin - Python best practices\n“Database Design for Mere Mortals” by Michael Hernandez - Data modeling\n“Site Reliability Engineering” by Google - DevOps practices\n\n\n\n\n\n“Introduction to Algorithms” (CLRS) - Algorithm fundamentals\n“Patterns of Enterprise Application Architecture” by Martin Fowler - Design patterns\n“The Mythical Man-Month” by Frederick Brooks - Software project management\n\n\n\n\n\n\n\n\n\nBooks Completed: 12 technical books\nPages Read: 3,000+ pages\nNotes Written: 50+ detailed notes\nProjects Built: 5+ implementations based on book concepts\n\n\n\n\n\nSystem Design: Master scalable architecture patterns\nDSA: Improve problem-solving and algorithmic thinking\nDevOps: Learn modern infrastructure and deployment practices\nSecurity: Build secure applications and systems\n\n\n\n\n\n\n\n\n“Clean Code” - Every developer should read this\n“The Pragmatic Programmer” - Timeless software development wisdom\n“Designing Data-Intensive Applications” - Excellent distributed systems coverage\n\n\n\n\n\n“Cracking the Coding Interview” - Great for interview preparation\n“Effective Python” - Python-specific best practices\n“Building Microservices” - Good microservices introduction\n\n\n\n\n\n“Head First Design Patterns” - Accessible design patterns introduction\n“Python Cookbook” - Practical Python recipes\n“Docker in Action” - Container fundamentals\n\n\n\n\n\n\n\n\nO’Reilly Learning: Online platform with technical books\nManning Publications: High-quality programming books\nPragmatic Bookshelf: Practical programming guides\nAddison-Wesley: Computer science and engineering books\n\n\n\n\n\nOnline Courses: Coursera, edX, Udemy courses\nDocumentation: Official docs and tutorials\nBlog Posts: Author blogs and technical articles\nVideo Content: Conference talks and tutorials\n\n\n\n\n\nLeetCode: Algorithm problems and solutions\nHackerRank: Programming challenges\nGitHub: Open source projects and examples\nPersonal Projects: Implementing book concepts\n\n\n\n\n\n\n\n\nE-reader: Kindle for digital books\nNote-taking: Notion for organized notes\nCode Editor: VS Code for examples and practice\nTime Tracking: Toggl for reading sessions\n\n\n\n\n\nWeekdays: 30-60 minutes before work\nWeekends: 2-3 hours for deep reading\nCommute: Audiobooks and podcasts\nEvenings: Code practice and implementation\n\n\n\n\n\n\n\n\nLocal Meetups: In-person book discussions\nOnline Forums: Reddit, Discord study groups\nBook Clubs: Organized reading groups\nMentorship: Teaching others while learning\n\n\n\n\n\nBlog Posts: Book reviews and summaries\nCode Examples: GitHub repositories with implementations\nVideo Content: Explaining concepts to others\nPresentations: Sharing learnings with teams\n\n\n\n\n\n\n\n\nBooks Read: 12+ per year\nNotes Written: 100+ detailed notes\nProjects Completed: 10+ implementations\nConcepts Mastered: 50+ key concepts\n\n\n\n\n\nUnderstanding: Deep comprehension of concepts\nApplication: Ability to use knowledge in projects\nTeaching: Can explain concepts to others\nProblem Solving: Improved analytical thinking\n\n\n\n\n\n\n\nReading Tips\n\n\n\n\nStart Small: Begin with shorter, focused books\nTake Notes: Document key concepts and insights\nPractice: Implement examples and build projects\nReview: Regularly revisit notes and concepts\nShare: Discuss learnings with others\n\n\n\n\n\n\n\n\n\nCommon Pitfalls\n\n\n\n\nOverwhelming: Don’t try to read too many books at once\nPassive Reading: Engage actively with the material\nNo Practice: Reading without implementation\nIsolation: Learning without community discussion",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "books/index.html#quick-navigation",
    "href": "books/index.html#quick-navigation",
    "title": "Books",
    "section": "",
    "text": "Reading List - Current and planned books\nNotes - Detailed book notes and summaries",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "books/index.html#reading-categories",
    "href": "books/index.html#reading-categories",
    "title": "Books",
    "section": "",
    "text": "Core Fundamentals: Algorithm design, complexity analysis\nProblem Solving: Interview preparation, competitive programming\nAdvanced Topics: Dynamic programming, graph algorithms\n\n\n\n\n\nDistributed Systems: Scalability, consistency, fault tolerance\nSoftware Architecture: Design patterns, best practices\nCloud-Native: Microservices, containers, serverless\n\n\n\n\n\nLanguage Deep Dives: Python, JavaScript, Go, Rust\nProgramming Paradigms: Functional, object-oriented, concurrent\nCode Quality: Clean code, refactoring, testing\n\n\n\n\n\nContainerization: Docker, Kubernetes, orchestration\nCloud Platforms: AWS, GCP, Azure services and patterns\nMonitoring & Observability: Logging, metrics, tracing\n\n\n\n\n\nApplication Security: OWASP, secure coding practices\nInfrastructure Security: Network security, access control\nCompliance: GDPR, SOC2, security frameworks\n\n\n\n\n\nDatabase Design: SQL, NoSQL, data modeling\nData Engineering: ETL, data pipelines, analytics\nMachine Learning: Algorithms, frameworks, MLOps",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "books/index.html#my-reading-approach",
    "href": "books/index.html#my-reading-approach",
    "title": "Books",
    "section": "",
    "text": "Current Needs: Books relevant to my current projects\nSkill Gaps: Areas where I need improvement\nIndustry Trends: Emerging technologies and practices\nClassics: Timeless books that every developer should read\n\n\n\n\n\nActive Reading: Take notes, highlight key concepts\nImplementation: Build examples and practice exercises\nReflection: Connect concepts to real-world applications\nSharing: Write summaries and share insights\n\n\n\n\n## Book: [Title]\n**Author**: [Author Name]  \n**Category**: [DSA/System Design/Programming/etc.]  \n**Status**: [Reading/Completed/Planned]  \n**Rating**: [1-5 stars]\n\n### Summary\n[2-3 sentence overview of the book]\n\n### Key Concepts\n- [Concept 1 with explanation]\n- [Concept 2 with explanation]\n- [Concept 3 with explanation]\n\n### Code Examples\n[Important code snippets and implementations]\n\n### Practical Applications\n[How to apply concepts in real projects]\n\n### Questions & Follow-up\n[Topics to explore further]",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "books/index.html#current-reading-status",
    "href": "books/index.html#current-reading-status",
    "title": "Books",
    "section": "",
    "text": "Progress: 60%\nCategory: System Design\nKey Learnings: Data models, storage engines, distributed systems\nRecent Notes: - Chapter 3: Storage and Retrieval - B-tree vs LSM-tree trade-offs - Chapter 4: Encoding and Evolution - Schema evolution strategies - Chapter 5: Replication - Leader-follower, consensus algorithms\n\n\n\nProgress: 40%\nCategory: DSA\nKey Learnings: Problem-solving techniques, interview strategies\nRecent Notes: - Arrays & Strings: Two pointers, sliding window techniques - Linked Lists: Fast/slow pointers, reversing, merging - Trees & Graphs: DFS/BFS, tree construction patterns\n\n\n\n\n\n\nRating: ⭐⭐⭐⭐⭐\nCategory: Programming\nKey Takeaways: Meaningful names, small functions, SOLID principles\nImpact: Improved code organization and maintainability in current projects.\n\n\n\nRating: ⭐⭐⭐⭐⭐\nCategory: Programming\nKey Takeaways: DRY principle, automation, continuous learning\nImpact: Enhanced development workflow and tool usage.\n\n\n\n\n\n\n\n“System Design Interview” by Alex Xu - Interview preparation\n“Building Microservices” by Sam Newman - Architecture patterns\n“Kubernetes in Action” by Marko Lukša - Container orchestration\n\n\n\n\n\n“Effective Python” by Brett Slatkin - Python best practices\n“Database Design for Mere Mortals” by Michael Hernandez - Data modeling\n“Site Reliability Engineering” by Google - DevOps practices\n\n\n\n\n\n“Introduction to Algorithms” (CLRS) - Algorithm fundamentals\n“Patterns of Enterprise Application Architecture” by Martin Fowler - Design patterns\n“The Mythical Man-Month” by Frederick Brooks - Software project management",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "books/index.html#reading-goals",
    "href": "books/index.html#reading-goals",
    "title": "Books",
    "section": "",
    "text": "Books Completed: 12 technical books\nPages Read: 3,000+ pages\nNotes Written: 50+ detailed notes\nProjects Built: 5+ implementations based on book concepts\n\n\n\n\n\nSystem Design: Master scalable architecture patterns\nDSA: Improve problem-solving and algorithmic thinking\nDevOps: Learn modern infrastructure and deployment practices\nSecurity: Build secure applications and systems",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "books/index.html#book-reviews-ratings",
    "href": "books/index.html#book-reviews-ratings",
    "title": "Books",
    "section": "",
    "text": "“Clean Code” - Every developer should read this\n“The Pragmatic Programmer” - Timeless software development wisdom\n“Designing Data-Intensive Applications” - Excellent distributed systems coverage\n\n\n\n\n\n“Cracking the Coding Interview” - Great for interview preparation\n“Effective Python” - Python-specific best practices\n“Building Microservices” - Good microservices introduction\n\n\n\n\n\n“Head First Design Patterns” - Accessible design patterns introduction\n“Python Cookbook” - Practical Python recipes\n“Docker in Action” - Container fundamentals",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "books/index.html#learning-resources",
    "href": "books/index.html#learning-resources",
    "title": "Books",
    "section": "",
    "text": "O’Reilly Learning: Online platform with technical books\nManning Publications: High-quality programming books\nPragmatic Bookshelf: Practical programming guides\nAddison-Wesley: Computer science and engineering books\n\n\n\n\n\nOnline Courses: Coursera, edX, Udemy courses\nDocumentation: Official docs and tutorials\nBlog Posts: Author blogs and technical articles\nVideo Content: Conference talks and tutorials\n\n\n\n\n\nLeetCode: Algorithm problems and solutions\nHackerRank: Programming challenges\nGitHub: Open source projects and examples\nPersonal Projects: Implementing book concepts",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "books/index.html#reading-environment",
    "href": "books/index.html#reading-environment",
    "title": "Books",
    "section": "",
    "text": "E-reader: Kindle for digital books\nNote-taking: Notion for organized notes\nCode Editor: VS Code for examples and practice\nTime Tracking: Toggl for reading sessions\n\n\n\n\n\nWeekdays: 30-60 minutes before work\nWeekends: 2-3 hours for deep reading\nCommute: Audiobooks and podcasts\nEvenings: Code practice and implementation",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "books/index.html#community-sharing",
    "href": "books/index.html#community-sharing",
    "title": "Books",
    "section": "",
    "text": "Local Meetups: In-person book discussions\nOnline Forums: Reddit, Discord study groups\nBook Clubs: Organized reading groups\nMentorship: Teaching others while learning\n\n\n\n\n\nBlog Posts: Book reviews and summaries\nCode Examples: GitHub repositories with implementations\nVideo Content: Explaining concepts to others\nPresentations: Sharing learnings with teams",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "books/index.html#success-metrics",
    "href": "books/index.html#success-metrics",
    "title": "Books",
    "section": "",
    "text": "Books Read: 12+ per year\nNotes Written: 100+ detailed notes\nProjects Completed: 10+ implementations\nConcepts Mastered: 50+ key concepts\n\n\n\n\n\nUnderstanding: Deep comprehension of concepts\nApplication: Ability to use knowledge in projects\nTeaching: Can explain concepts to others\nProblem Solving: Improved analytical thinking\n\n\n\n\n\n\n\nReading Tips\n\n\n\n\nStart Small: Begin with shorter, focused books\nTake Notes: Document key concepts and insights\nPractice: Implement examples and build projects\nReview: Regularly revisit notes and concepts\nShare: Discuss learnings with others\n\n\n\n\n\n\n\n\n\nCommon Pitfalls\n\n\n\n\nOverwhelming: Don’t try to read too many books at once\nPassive Reading: Engage actively with the material\nNo Practice: Reading without implementation\nIsolation: Learning without community discussion",
    "crumbs": [
      "Books"
    ]
  },
  {
    "objectID": "blog/system-design-learning-path.html",
    "href": "blog/system-design-learning-path.html",
    "title": "My System Design Learning Path",
    "section": "",
    "text": "After spending several months studying system design, I wanted to share my structured approach to learning this complex topic. System design is one of the most challenging areas in software engineering, but with the right approach, it becomes manageable and even enjoyable.\n\n\nSystem design interviews are a crucial part of the software engineering interview process, especially for senior positions. But beyond interviews, understanding system design principles is essential for:\n\nBuilding Scalable Applications: Understanding how to handle growth\nMaking Architectural Decisions: Choosing the right patterns and technologies\nDebugging Distributed Systems: Identifying bottlenecks and failure points\nCollaborating with Teams: Communicating design decisions effectively\n\n\n\n\n\n\nI started with the basics to build a strong foundation:\n\n\n\nVertical vs Horizontal Scaling: Understanding the difference and trade-offs\nLoad Balancing: Different algorithms and their use cases\nCaching Strategies: When and how to use caching effectively\n\n# Example: Simple load balancer implementation\nclass RoundRobinLoadBalancer:\n    def __init__(self, servers):\n        self.servers = servers\n        self.current_index = 0\n    \n    def get_next_server(self):\n        server = self.servers[self.current_index]\n        self.current_index = (self.current_index + 1) % len(self.servers)\n        return server\n\n\n\n\nACID Properties: Understanding transaction guarantees\nCAP Theorem: Consistency, Availability, Partition Tolerance trade-offs\nDatabase Types: Relational vs NoSQL, when to use each\n\n\n\n\n\nHTTP vs HTTPS: Security and performance implications\nREST vs gRPC: API design patterns\nCDN: Content delivery optimization\n\n\n\n\n\nOnce I had the fundamentals, I moved to architectural patterns:\n\n\n\nService Decomposition: How to break down monolithic applications\nService Communication: Synchronous vs asynchronous patterns\nData Management: Database per service vs shared database\n\n# Example: Circuit breaker pattern for service communication\nclass CircuitBreaker:\n    def __init__(self, failure_threshold=5, timeout=60):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failure_count = 0\n        self.last_failure_time = None\n        self.state = 'CLOSED'\n    \n    def call(self, func, *args, **kwargs):\n        if self.state == 'OPEN':\n            if time.time() - self.last_failure_time &gt; self.timeout:\n                self.state = 'HALF_OPEN'\n            else:\n                raise Exception(\"Circuit breaker is OPEN\")\n        \n        try:\n            result = func(*args, **kwargs)\n            if self.state == 'HALF_OPEN':\n                self.state = 'CLOSED'\n                self.failure_count = 0\n            return result\n        except Exception as e:\n            self.failure_count += 1\n            self.last_failure_time = time.time()\n            \n            if self.failure_count &gt;= self.failure_threshold:\n                self.state = 'OPEN'\n            \n            raise e\n\n\n\n\nEvent Sourcing: Storing events instead of state\nCQRS: Command Query Responsibility Segregation\nMessage Queues: Apache Kafka, RabbitMQ patterns\n\n\n\n\n\nRead Replicas: Scaling read operations\nSharding: Horizontal data partitioning\nCaching Layers: Application, database, and CDN caching\n\n\n\n\n\nThe final phase focused on complex distributed systems:\n\n\n\nPaxos and Raft: Understanding distributed consensus\nLeader Election: Handling node failures\nReplication: Ensuring data consistency\n\n\n\n\n\nLatency vs Throughput: Understanding performance metrics\nBottleneck Identification: Finding and fixing performance issues\nMonitoring and Observability: Tools and techniques\n\n\n\n\n\nAuthentication and Authorization: Securing distributed systems\nFault Tolerance: Handling failures gracefully\nDisaster Recovery: Backup and recovery strategies\n\n\n\n\n\n\n\n\nI analyzed real-world system designs from companies like: - Netflix: Microservices and chaos engineering - Uber: Real-time data processing - Airbnb: Scalable booking systems - Google: Distributed databases (Spanner)\n\n\n\nBuilding small-scale distributed systems helped me understand the challenges:\n# Example: Simple distributed cache implementation\nclass DistributedCache:\n    def __init__(self, nodes):\n        self.nodes = nodes\n        self.consistent_hash = ConsistentHash(nodes)\n    \n    def get(self, key):\n        node = self.consistent_hash.get_node(key)\n        return node.get(key)\n    \n    def set(self, key, value):\n        node = self.consistent_hash.get_node(key)\n        return node.set(key, value)\n\n\n\nRegular mock interviews helped me: - Structure My Thinking: Following a systematic approach - Communicate Clearly: Explaining complex concepts simply - Handle Edge Cases: Considering failure scenarios - Time Management: Completing designs within time limits\n\n\n\n\n\n\n\n“Designing Data-Intensive Applications” by Martin Kleppmann\n“System Design Interview” by Alex Xu\n“Building Microservices” by Sam Newman\n\n\n\n\n\nHigh Scalability: Real-world architecture examples\nAWS Architecture Center: Cloud-specific patterns\nMartin Fowler’s Blog: Software architecture insights\n\n\n\n\n\nGrokking the System Design Interview\nSystem Design Primer (GitHub)\nInterviewBit System Design\n\n\n\n\n\n\n\n\nStart simple and add complexity as needed\nDon’t solve problems you don’t have\nFocus on the core requirements first\n\n\n\n\n\nAlways consider scalability, availability, and performance\nAsk clarifying questions about requirements\nMake trade-offs explicit\n\n\n\n\n\nDraw diagrams to visualize your design\nExplain your reasoning and trade-offs\nBe ready to iterate based on feedback\n\n\n\n\n\nAfter completing this learning path, I’m now focusing on:\n\n\n\nKubernetes: Container orchestration and microservices\nApache Kafka: Event streaming and real-time processing\nRedis: Advanced caching patterns and data structures\n\n\n\n\n\nBuilding scalable web applications\nImplementing microservices architectures\nWorking with cloud platforms (AWS, GCP)\n\n\n\n\n\nWriting blog posts about system design\nContributing to open source projects\nMentoring others in their learning journey\n\n\n\n\n\n\n\nDon’t rush into complex topics. Build a strong foundation first.\n\n\n\nSystem design is a skill that improves with practice. Do mock interviews and build projects.\n\n\n\nStudy how companies like Netflix, Uber, and Google solve real problems.\n\n\n\nEvery design decision involves trade-offs. Understand and communicate them clearly.\n\n\n\nTechnology evolves quickly. Keep learning about new patterns and tools.\n\n\n\n\nLearning system design is a journey, not a destination. The field is constantly evolving, and there’s always more to learn. The key is to approach it systematically, practice regularly, and learn from both successes and failures.\nMy learning path has been challenging but incredibly rewarding. I’ve gained a deeper understanding of how large-scale systems work, and I’m excited to continue learning and growing in this area.\nIf you’re on a similar journey, I’d love to hear about your experiences and learn from your insights. Feel free to reach out and share your own learning path!\n\nWhat’s your system design learning journey been like? What resources or approaches have been most helpful for you? Share your thoughts in the comments below!"
  },
  {
    "objectID": "blog/system-design-learning-path.html#why-system-design-matters",
    "href": "blog/system-design-learning-path.html#why-system-design-matters",
    "title": "My System Design Learning Path",
    "section": "",
    "text": "System design interviews are a crucial part of the software engineering interview process, especially for senior positions. But beyond interviews, understanding system design principles is essential for:\n\nBuilding Scalable Applications: Understanding how to handle growth\nMaking Architectural Decisions: Choosing the right patterns and technologies\nDebugging Distributed Systems: Identifying bottlenecks and failure points\nCollaborating with Teams: Communicating design decisions effectively"
  },
  {
    "objectID": "blog/system-design-learning-path.html#my-learning-approach",
    "href": "blog/system-design-learning-path.html#my-learning-approach",
    "title": "My System Design Learning Path",
    "section": "",
    "text": "I started with the basics to build a strong foundation:\n\n\n\nVertical vs Horizontal Scaling: Understanding the difference and trade-offs\nLoad Balancing: Different algorithms and their use cases\nCaching Strategies: When and how to use caching effectively\n\n# Example: Simple load balancer implementation\nclass RoundRobinLoadBalancer:\n    def __init__(self, servers):\n        self.servers = servers\n        self.current_index = 0\n    \n    def get_next_server(self):\n        server = self.servers[self.current_index]\n        self.current_index = (self.current_index + 1) % len(self.servers)\n        return server\n\n\n\n\nACID Properties: Understanding transaction guarantees\nCAP Theorem: Consistency, Availability, Partition Tolerance trade-offs\nDatabase Types: Relational vs NoSQL, when to use each\n\n\n\n\n\nHTTP vs HTTPS: Security and performance implications\nREST vs gRPC: API design patterns\nCDN: Content delivery optimization\n\n\n\n\n\nOnce I had the fundamentals, I moved to architectural patterns:\n\n\n\nService Decomposition: How to break down monolithic applications\nService Communication: Synchronous vs asynchronous patterns\nData Management: Database per service vs shared database\n\n# Example: Circuit breaker pattern for service communication\nclass CircuitBreaker:\n    def __init__(self, failure_threshold=5, timeout=60):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failure_count = 0\n        self.last_failure_time = None\n        self.state = 'CLOSED'\n    \n    def call(self, func, *args, **kwargs):\n        if self.state == 'OPEN':\n            if time.time() - self.last_failure_time &gt; self.timeout:\n                self.state = 'HALF_OPEN'\n            else:\n                raise Exception(\"Circuit breaker is OPEN\")\n        \n        try:\n            result = func(*args, **kwargs)\n            if self.state == 'HALF_OPEN':\n                self.state = 'CLOSED'\n                self.failure_count = 0\n            return result\n        except Exception as e:\n            self.failure_count += 1\n            self.last_failure_time = time.time()\n            \n            if self.failure_count &gt;= self.failure_threshold:\n                self.state = 'OPEN'\n            \n            raise e\n\n\n\n\nEvent Sourcing: Storing events instead of state\nCQRS: Command Query Responsibility Segregation\nMessage Queues: Apache Kafka, RabbitMQ patterns\n\n\n\n\n\nRead Replicas: Scaling read operations\nSharding: Horizontal data partitioning\nCaching Layers: Application, database, and CDN caching\n\n\n\n\n\nThe final phase focused on complex distributed systems:\n\n\n\nPaxos and Raft: Understanding distributed consensus\nLeader Election: Handling node failures\nReplication: Ensuring data consistency\n\n\n\n\n\nLatency vs Throughput: Understanding performance metrics\nBottleneck Identification: Finding and fixing performance issues\nMonitoring and Observability: Tools and techniques\n\n\n\n\n\nAuthentication and Authorization: Securing distributed systems\nFault Tolerance: Handling failures gracefully\nDisaster Recovery: Backup and recovery strategies"
  },
  {
    "objectID": "blog/system-design-learning-path.html#practical-learning-methods",
    "href": "blog/system-design-learning-path.html#practical-learning-methods",
    "title": "My System Design Learning Path",
    "section": "",
    "text": "I analyzed real-world system designs from companies like: - Netflix: Microservices and chaos engineering - Uber: Real-time data processing - Airbnb: Scalable booking systems - Google: Distributed databases (Spanner)\n\n\n\nBuilding small-scale distributed systems helped me understand the challenges:\n# Example: Simple distributed cache implementation\nclass DistributedCache:\n    def __init__(self, nodes):\n        self.nodes = nodes\n        self.consistent_hash = ConsistentHash(nodes)\n    \n    def get(self, key):\n        node = self.consistent_hash.get_node(key)\n        return node.get(key)\n    \n    def set(self, key, value):\n        node = self.consistent_hash.get_node(key)\n        return node.set(key, value)\n\n\n\nRegular mock interviews helped me: - Structure My Thinking: Following a systematic approach - Communicate Clearly: Explaining complex concepts simply - Handle Edge Cases: Considering failure scenarios - Time Management: Completing designs within time limits"
  },
  {
    "objectID": "blog/system-design-learning-path.html#key-resources",
    "href": "blog/system-design-learning-path.html#key-resources",
    "title": "My System Design Learning Path",
    "section": "",
    "text": "“Designing Data-Intensive Applications” by Martin Kleppmann\n“System Design Interview” by Alex Xu\n“Building Microservices” by Sam Newman\n\n\n\n\n\nHigh Scalability: Real-world architecture examples\nAWS Architecture Center: Cloud-specific patterns\nMartin Fowler’s Blog: Software architecture insights\n\n\n\n\n\nGrokking the System Design Interview\nSystem Design Primer (GitHub)\nInterviewBit System Design"
  },
  {
    "objectID": "blog/system-design-learning-path.html#common-mistakes-to-avoid",
    "href": "blog/system-design-learning-path.html#common-mistakes-to-avoid",
    "title": "My System Design Learning Path",
    "section": "",
    "text": "Start simple and add complexity as needed\nDon’t solve problems you don’t have\nFocus on the core requirements first\n\n\n\n\n\nAlways consider scalability, availability, and performance\nAsk clarifying questions about requirements\nMake trade-offs explicit\n\n\n\n\n\nDraw diagrams to visualize your design\nExplain your reasoning and trade-offs\nBe ready to iterate based on feedback"
  },
  {
    "objectID": "blog/system-design-learning-path.html#my-current-focus",
    "href": "blog/system-design-learning-path.html#my-current-focus",
    "title": "My System Design Learning Path",
    "section": "",
    "text": "After completing this learning path, I’m now focusing on:\n\n\n\nKubernetes: Container orchestration and microservices\nApache Kafka: Event streaming and real-time processing\nRedis: Advanced caching patterns and data structures\n\n\n\n\n\nBuilding scalable web applications\nImplementing microservices architectures\nWorking with cloud platforms (AWS, GCP)\n\n\n\n\n\nWriting blog posts about system design\nContributing to open source projects\nMentoring others in their learning journey"
  },
  {
    "objectID": "blog/system-design-learning-path.html#tips-for-success",
    "href": "blog/system-design-learning-path.html#tips-for-success",
    "title": "My System Design Learning Path",
    "section": "",
    "text": "Don’t rush into complex topics. Build a strong foundation first.\n\n\n\nSystem design is a skill that improves with practice. Do mock interviews and build projects.\n\n\n\nStudy how companies like Netflix, Uber, and Google solve real problems.\n\n\n\nEvery design decision involves trade-offs. Understand and communicate them clearly.\n\n\n\nTechnology evolves quickly. Keep learning about new patterns and tools."
  },
  {
    "objectID": "blog/system-design-learning-path.html#conclusion",
    "href": "blog/system-design-learning-path.html#conclusion",
    "title": "My System Design Learning Path",
    "section": "",
    "text": "Learning system design is a journey, not a destination. The field is constantly evolving, and there’s always more to learn. The key is to approach it systematically, practice regularly, and learn from both successes and failures.\nMy learning path has been challenging but incredibly rewarding. I’ve gained a deeper understanding of how large-scale systems work, and I’m excited to continue learning and growing in this area.\nIf you’re on a similar journey, I’d love to hear about your experiences and learn from your insights. Feel free to reach out and share your own learning path!\n\nWhat’s your system design learning journey been like? What resources or approaches have been most helpful for you? Share your thoughts in the comments below!"
  },
  {
    "objectID": "system-design/index.html",
    "href": "system-design/index.html",
    "title": "System Design",
    "section": "",
    "text": "Welcome to my System Design learning journey! This section covers scalable architecture patterns, distributed systems, and real-world system design challenges.",
    "crumbs": [
      "System Design"
    ]
  },
  {
    "objectID": "system-design/index.html#what-is-system-design",
    "href": "system-design/index.html#what-is-system-design",
    "title": "System Design",
    "section": "What is System Design?",
    "text": "What is System Design?\nSystem design is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. It’s about making trade-offs between different aspects like:\n\nScalability: How well the system handles growth\nReliability: How often the system fails\nAvailability: How much time the system is operational\nPerformance: How fast the system responds\nMaintainability: How easy it is to modify and extend",
    "crumbs": [
      "System Design"
    ]
  },
  {
    "objectID": "system-design/index.html#system-design-interview-process",
    "href": "system-design/index.html#system-design-interview-process",
    "title": "System Design",
    "section": "System Design Interview Process",
    "text": "System Design Interview Process\n\n1. Requirements Gathering\n\nFunctional Requirements: What the system should do\nNon-Functional Requirements: Performance, scalability, availability\nConstraints: Budget, timeline, technology stack\n\n\n\n2. Capacity Planning\n\nTraffic Estimation: Requests per second, data storage needs\nStorage Calculation: Data size, growth rate\nBandwidth Requirements: Network capacity needed\n\n\n\n3. High-Level Design\n\nSystem Architecture: Overall structure and components\nDatabase Design: Data models and storage strategies\nAPI Design: Interface definitions and protocols\n\n\n\n4. Detailed Design\n\nComponent Design: Individual service specifications\nData Flow: How data moves through the system\nError Handling: Failure scenarios and recovery",
    "crumbs": [
      "System Design"
    ]
  },
  {
    "objectID": "system-design/index.html#key-concepts",
    "href": "system-design/index.html#key-concepts",
    "title": "System Design",
    "section": "Key Concepts",
    "text": "Key Concepts\n\nScalability\n\nHorizontal Scaling: Adding more machines\nVertical Scaling: Adding more resources to existing machines\nLoad Balancing: Distributing traffic across multiple servers\n\n\n\nAvailability\n\nRedundancy: Multiple copies of critical components\nFailover: Automatic switching to backup systems\nData Replication: Keeping data synchronized across locations\n\n\n\nConsistency\n\nACID Properties: Atomicity, Consistency, Isolation, Durability\nCAP Theorem: Consistency, Availability, Partition Tolerance\nEventual Consistency: Data becomes consistent over time\n\n\n\nPerformance\n\nLatency: Time to respond to a request\nThroughput: Number of requests handled per unit time\nCaching: Storing frequently accessed data",
    "crumbs": [
      "System Design"
    ]
  },
  {
    "objectID": "system-design/index.html#common-system-design-topics",
    "href": "system-design/index.html#common-system-design-topics",
    "title": "System Design",
    "section": "Common System Design Topics",
    "text": "Common System Design Topics\n\nWeb Applications\n\nClient-Server Architecture\nRESTful APIs\nMicroservices\nAPI Gateway Pattern\n\n\n\nData Storage\n\nRelational Databases: MySQL, PostgreSQL\nNoSQL Databases: MongoDB, Cassandra, Redis\nData Warehousing: BigQuery, Snowflake\nCDN: Content Delivery Networks\n\n\n\nMessaging Systems\n\nMessage Queues: RabbitMQ, Apache Kafka\nEvent-Driven Architecture\nPub/Sub Pattern\n\n\n\nMonitoring & Observability\n\nLogging: Centralized log management\nMetrics: Performance monitoring\nTracing: Distributed request tracking\nAlerting: Proactive issue detection",
    "crumbs": [
      "System Design"
    ]
  }
]