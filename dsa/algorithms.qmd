---
title: "Algorithms"
order: 3
---

# Algorithms

A comprehensive guide to fundamental algorithms and problem-solving techniques.

## Algorithmic Paradigms

### Brute Force
- **Description**: Try all possible solutions
- **Use Cases**: Small problem sizes, when optimal solution is needed
- **Example**: Generate all permutations, try all combinations

```python
# Generate all permutations
def permutations(nums):
    if len(nums) <= 1:
        return [nums]
    
    result = []
    for i in range(len(nums)):
        for perm in permutations(nums[:i] + nums[i+1:]):
            result.append([nums[i]] + perm)
    return result
```

### Divide and Conquer
- **Description**: Break problem into smaller subproblems, solve recursively, combine results
- **Time Complexity**: Often O(n log n)
- **Use Cases**: Sorting, searching, matrix multiplication

```python
# Merge Sort
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

### Dynamic Programming
- **Description**: Solve complex problems by breaking into simpler subproblems, store results
- **Use Cases**: Optimization problems, counting problems, path finding

```python
# Fibonacci with memoization
def fibonacci(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    
    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
    return memo[n]

# Longest Common Subsequence
def lcs(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

### Greedy Algorithms
- **Description**: Make locally optimal choice at each step
- **Use Cases**: Scheduling, Huffman coding, minimum spanning trees
- **Note**: May not always give optimal solution

```python
# Activity Selection Problem
def activity_selection(start, finish):
    n = len(start)
    selected = [0]  # First activity is always selected
    
    j = 0
    for i in range(1, n):
        if start[i] >= finish[j]:
            selected.append(i)
            j = i
    
    return selected
```

## Sorting Algorithms

### Comparison-based Sorting

#### Quick Sort
- **Time Complexity**: O(n log n) average, O(n²) worst
- **Space Complexity**: O(log n)
- **Stability**: Not stable

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)
```

#### Merge Sort
- **Time Complexity**: O(n log n)
- **Space Complexity**: O(n)
- **Stability**: Stable

#### Heap Sort
- **Time Complexity**: O(n log n)
- **Space Complexity**: O(1)
- **Stability**: Not stable

### Non-comparison Sorting

#### Counting Sort
- **Time Complexity**: O(n + k) where k is range of input
- **Use Cases**: When range of input is not much larger than number of objects

```python
def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)
    
    for num in arr:
        count[num] += 1
    
    result = []
    for i in range(len(count)):
        result.extend([i] * count[i])
    
    return result
```

## Searching Algorithms

### Binary Search
- **Time Complexity**: O(log n)
- **Prerequisite**: Array must be sorted

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1
```

## Graph Algorithms

### Breadth-First Search (BFS)
- **Time Complexity**: O(V + E)
- **Use Cases**: Shortest path in unweighted graphs, level-order traversal

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        vertex = queue.popleft()
        print(vertex, end=' ')
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

### Depth-First Search (DFS)
- **Time Complexity**: O(V + E)
- **Use Cases**: Topological sorting, cycle detection, maze solving

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    
    visited.add(start)
    print(start, end=' ')
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
```

## String Algorithms

### Pattern Matching

#### KMP Algorithm
- **Time Complexity**: O(n + m) where n is text length, m is pattern length
- **Use Cases**: Text search, DNA sequence matching

```python
def kmp_search(text, pattern):
    def compute_lps(pattern):
        lps = [0] * len(pattern)
        length = 0
        i = 1
        
        while i < len(pattern):
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        return lps
    
    lps = compute_lps(pattern)
    i = j = 0
    
    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1
        
        if j == len(pattern):
            return i - j
        elif i < len(text) and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return -1
```

## Algorithm Analysis

### Time Complexity
- **Big O Notation**: Upper bound on growth rate
- **Common Complexities**: O(1), O(log n), O(n), O(n log n), O(n²), O(2ⁿ)

### Space Complexity
- **Auxiliary Space**: Extra space used by algorithm
- **In-place Algorithms**: Use O(1) extra space

## Problem-Solving Strategies

::: {.callout-tip}
## Before Coding
1. Understand the problem completely
2. Identify input/output constraints
3. Consider edge cases
4. Choose appropriate data structure
5. Plan your algorithm
:::

::: {.callout-warning}
## Common Mistakes
- Not handling edge cases
- Incorrect time/space complexity analysis
- Over-optimizing prematurely
- Not testing with different inputs
::: 